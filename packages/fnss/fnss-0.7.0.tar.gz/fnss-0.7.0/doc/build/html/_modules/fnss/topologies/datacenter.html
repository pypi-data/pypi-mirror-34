
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>fnss.topologies.datacenter &#8212; FNSS 0.7.0 documentation</title>
    <link rel="stylesheet" href="../../../_static/sphinxdoc.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../../',
        VERSION:     '0.7.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true,
        SOURCELINK_SUFFIX: '.txt'
      };
    </script>
    <script type="text/javascript" src="../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../_static/doctools.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
  </head>
  <body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../../index.html">FNSS 0.7.0 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../../index.html" accesskey="U">Module code</a> &#187;</li> 
      </ul>
    </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="../../../search.html" method="get">
      <div><input type="text" name="q" /></div>
      <div><input type="submit" value="Go" /></div>
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for fnss.topologies.datacenter</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;Functions to generate commonly adopted datacenter topologies.</span>

<span class="sd">Each topology generation function returns an instance of DatacenterTopology</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">import</span> <span class="nn">networkx</span> <span class="k">as</span> <span class="nn">nx</span>
<span class="kn">from</span> <span class="nn">fnss.topologies.topology</span> <span class="k">import</span> <span class="n">Topology</span>


<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span>
    <span class="s1">&#39;DatacenterTopology&#39;</span><span class="p">,</span>
    <span class="s1">&#39;two_tier_topology&#39;</span><span class="p">,</span>
    <span class="s1">&#39;three_tier_topology&#39;</span><span class="p">,</span>
    <span class="s1">&#39;bcube_topology&#39;</span><span class="p">,</span>
    <span class="s1">&#39;fat_tree_topology&#39;</span>
           <span class="p">]</span>


<div class="viewcode-block" id="DatacenterTopology"><a class="viewcode-back" href="../../../apidoc/fnss.classes.html#fnss.topologies.datacenter.DatacenterTopology">[docs]</a><span class="k">class</span> <span class="nc">DatacenterTopology</span><span class="p">(</span><span class="n">Topology</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Represent a datacenter topology</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="DatacenterTopology.number_of_switches"><a class="viewcode-back" href="../../../apidoc/generated/fnss.topologies.datacenter.DatacenterTopology.number_of_switches.html#fnss.topologies.datacenter.DatacenterTopology.number_of_switches">[docs]</a>    <span class="k">def</span> <span class="nf">number_of_switches</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the number of switches in the topology</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">switches</span><span class="p">())</span></div>

<div class="viewcode-block" id="DatacenterTopology.number_of_hosts"><a class="viewcode-back" href="../../../apidoc/generated/fnss.topologies.datacenter.DatacenterTopology.number_of_hosts.html#fnss.topologies.datacenter.DatacenterTopology.number_of_hosts">[docs]</a>    <span class="k">def</span> <span class="nf">number_of_hosts</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the number of hosts in the topology</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">hosts</span><span class="p">())</span></div>

<div class="viewcode-block" id="DatacenterTopology.switches"><a class="viewcode-back" href="../../../apidoc/generated/fnss.topologies.datacenter.DatacenterTopology.switches.html#fnss.topologies.datacenter.DatacenterTopology.switches">[docs]</a>    <span class="k">def</span> <span class="nf">switches</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the list of switch nodes in the topology</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">v</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes_iter</span><span class="p">()</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">v</span><span class="p">][</span><span class="s1">&#39;type&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;switch&#39;</span><span class="p">]</span></div>

<div class="viewcode-block" id="DatacenterTopology.hosts"><a class="viewcode-back" href="../../../apidoc/generated/fnss.topologies.datacenter.DatacenterTopology.hosts.html#fnss.topologies.datacenter.DatacenterTopology.hosts">[docs]</a>    <span class="k">def</span> <span class="nf">hosts</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the list of host nodes in the topology</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">v</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes_iter</span><span class="p">()</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">v</span><span class="p">][</span><span class="s1">&#39;type&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;host&#39;</span><span class="p">]</span></div></div>


<div class="viewcode-block" id="two_tier_topology"><a class="viewcode-back" href="../../../apidoc/generated/fnss.topologies.datacenter.two_tier_topology.html#fnss.topologies.datacenter.two_tier_topology">[docs]</a><span class="k">def</span> <span class="nf">two_tier_topology</span><span class="p">(</span><span class="n">n_core</span><span class="p">,</span> <span class="n">n_edge</span><span class="p">,</span> <span class="n">n_hosts</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return a two-tier datacenter topology.</span>

<span class="sd">    This topology comprises switches organized in two tiers (core and edge) and</span>
<span class="sd">    hosts connected to edge routers. Each core switch is connected to each</span>
<span class="sd">    edge switch while each host is connected to exactly one edge switch.</span>

<span class="sd">    Each node has two attributes:</span>
<span class="sd">     * type: can either be *switch* or *host*</span>
<span class="sd">     * tier: can either be *core*, *edge* or *leaf*. Nodes in the leaf tier are</span>
<span class="sd">       only host, while all core and edge nodes are switches.</span>

<span class="sd">    Each edge has an attribute type as well which can either be *core_edge* if</span>
<span class="sd">    it connects a core and an edge switch or *edge_leaf* if it connects an edge</span>
<span class="sd">    switch to a host.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    n_core : int</span>
<span class="sd">        Total number of core switches</span>
<span class="sd">    n_edge : int</span>
<span class="sd">        Total number of edge switches</span>
<span class="sd">    n_hosts : int</span>
<span class="sd">        Number of hosts connected to each edge switch.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    topology : DatacenterTopology</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># validate input arguments</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="p">(</span><span class="n">n_core</span><span class="p">,</span> <span class="n">n_edge</span><span class="p">,</span> <span class="n">n_hosts</span><span class="p">)):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;n_core, n_edge and n_hosts must be integers&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">n_core</span> <span class="o">&lt;</span> <span class="mi">1</span> <span class="ow">or</span> <span class="n">n_edge</span> <span class="o">&lt;</span> <span class="mi">1</span> <span class="ow">or</span> <span class="n">n_hosts</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;n_core, n_edge and n_hosts must be positive&#39;</span><span class="p">)</span>

    <span class="n">topo</span> <span class="o">=</span> <span class="n">DatacenterTopology</span><span class="p">(</span><span class="n">nx</span><span class="o">.</span><span class="n">complete_bipartite_graph</span><span class="p">(</span><span class="n">n_core</span><span class="p">,</span> <span class="n">n_edge</span><span class="p">))</span>
    <span class="n">topo</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;two_tier_topology(</span><span class="si">%d</span><span class="s2">,</span><span class="si">%d</span><span class="s2">,</span><span class="si">%d</span><span class="s2">)&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">n_core</span><span class="p">,</span> <span class="n">n_edge</span><span class="p">,</span> <span class="n">n_hosts</span><span class="p">)</span>
    <span class="n">topo</span><span class="o">.</span><span class="n">graph</span><span class="p">[</span><span class="s1">&#39;type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;two_tier&#39;</span>
    <span class="k">for</span> <span class="n">u</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_core</span><span class="p">):</span>
        <span class="n">topo</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">u</span><span class="p">][</span><span class="s1">&#39;tier&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;core&#39;</span>
        <span class="n">topo</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">u</span><span class="p">][</span><span class="s1">&#39;type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;switch&#39;</span>
        <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">topo</span><span class="o">.</span><span class="n">edge</span><span class="p">[</span><span class="n">u</span><span class="p">]:</span>
            <span class="n">topo</span><span class="o">.</span><span class="n">edge</span><span class="p">[</span><span class="n">u</span><span class="p">][</span><span class="n">v</span><span class="p">][</span><span class="s1">&#39;type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;core_edge&#39;</span>
    <span class="k">for</span> <span class="n">u</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_core</span><span class="p">,</span> <span class="n">n_core</span> <span class="o">+</span> <span class="n">n_edge</span><span class="p">):</span>
        <span class="n">topo</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">u</span><span class="p">][</span><span class="s1">&#39;tier&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;edge&#39;</span>
        <span class="n">topo</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">u</span><span class="p">][</span><span class="s1">&#39;type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;switch&#39;</span>
        <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_hosts</span><span class="p">):</span>
            <span class="n">v</span> <span class="o">=</span> <span class="n">topo</span><span class="o">.</span><span class="n">number_of_nodes</span><span class="p">()</span>
            <span class="n">topo</span><span class="o">.</span><span class="n">add_node</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
            <span class="n">topo</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">v</span><span class="p">][</span><span class="s1">&#39;tier&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;leaf&#39;</span>
            <span class="n">topo</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">v</span><span class="p">][</span><span class="s1">&#39;type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;host&#39;</span>
            <span class="n">topo</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="s1">&#39;edge_leaf&#39;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">topo</span></div>


<div class="viewcode-block" id="three_tier_topology"><a class="viewcode-back" href="../../../apidoc/generated/fnss.topologies.datacenter.three_tier_topology.html#fnss.topologies.datacenter.three_tier_topology">[docs]</a><span class="k">def</span> <span class="nf">three_tier_topology</span><span class="p">(</span><span class="n">n_core</span><span class="p">,</span> <span class="n">n_aggregation</span><span class="p">,</span> <span class="n">n_edge</span><span class="p">,</span> <span class="n">n_hosts</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return a three-tier data center topology.</span>

<span class="sd">    This topology  comprises switches organized in three tiers (core,</span>
<span class="sd">    aggregation and edge) and hosts connected to edge routers. Each core</span>
<span class="sd">    switch is connected to each aggregation, each edge switch is connected to</span>
<span class="sd">    one aggregation switch and finally each host is connected to exactly one</span>
<span class="sd">    edge switch.</span>

<span class="sd">    Each node has two attributes:</span>
<span class="sd">     * type: can either be *switch* or *host*</span>
<span class="sd">     * tier: can either be *core*, *aggregation*, *edge* or *leaf*. Nodes in</span>
<span class="sd">       the leaf tier are only host, while all core, aggregation and edge</span>
<span class="sd">       nodes are switches.</span>

<span class="sd">    Each edge has an attribute type as well which can either be *core_edge* if</span>
<span class="sd">    it connects a core and an aggregation switch, *aggregation_edge*, if it</span>
<span class="sd">    connects an aggregation and a core switch or *edge_leaf* if it connects an</span>
<span class="sd">    edge switch to a host.</span>

<span class="sd">    The total number of hosts is</span>
<span class="sd">    :math:`n_{aggregation} * n_{edge} * n_{hosts}`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    n_core : int</span>
<span class="sd">        Total number of core switches</span>
<span class="sd">    n_aggregation : int</span>
<span class="sd">        Total number of aggregation switches</span>
<span class="sd">    n_edge : int</span>
<span class="sd">        Number of edge switches per each each aggregation switch</span>
<span class="sd">    n_hosts : int</span>
<span class="sd">        Number of hosts connected to each edge switch.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    topology : DatacenterTopology</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Validate input arguments</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span>
               <span class="p">(</span><span class="n">n_core</span><span class="p">,</span> <span class="n">n_aggregation</span><span class="p">,</span> <span class="n">n_edge</span><span class="p">,</span> <span class="n">n_hosts</span><span class="p">)):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;n_core, n_edge, n_aggregation and n_hosts &#39;</span>\
                        <span class="s1">&#39;must be integers&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">n_core</span> <span class="o">&lt;</span> <span class="mi">1</span> <span class="ow">or</span> <span class="n">n_aggregation</span> <span class="o">&lt;</span> <span class="mi">1</span> <span class="ow">or</span> <span class="n">n_edge</span> <span class="o">&lt;</span> <span class="mi">1</span> <span class="ow">or</span> <span class="n">n_hosts</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;n_core, n_aggregation, n_edge and n_host &#39;</span>\
                         <span class="s1">&#39;must be positive&#39;</span><span class="p">)</span>

    <span class="n">topo</span> <span class="o">=</span> <span class="n">DatacenterTopology</span><span class="p">(</span><span class="n">nx</span><span class="o">.</span><span class="n">complete_bipartite_graph</span><span class="p">(</span><span class="n">n_core</span><span class="p">,</span>
                                                          <span class="n">n_aggregation</span><span class="p">))</span>
    <span class="n">topo</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;three_tier_topology(</span><span class="si">%d</span><span class="s2">,</span><span class="si">%d</span><span class="s2">,</span><span class="si">%d</span><span class="s2">,</span><span class="si">%d</span><span class="s2">)&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">n_core</span><span class="p">,</span> <span class="n">n_aggregation</span><span class="p">,</span>
                                                      <span class="n">n_edge</span><span class="p">,</span> <span class="n">n_hosts</span><span class="p">)</span>
    <span class="n">topo</span><span class="o">.</span><span class="n">graph</span><span class="p">[</span><span class="s1">&#39;type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;three_tier&#39;</span>
    <span class="k">for</span> <span class="n">u</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_core</span><span class="p">):</span>
        <span class="n">topo</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">u</span><span class="p">][</span><span class="s1">&#39;tier&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;core&#39;</span>
        <span class="n">topo</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">u</span><span class="p">][</span><span class="s1">&#39;type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;switch&#39;</span>
        <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">topo</span><span class="o">.</span><span class="n">edge</span><span class="p">[</span><span class="n">u</span><span class="p">]:</span>
            <span class="n">topo</span><span class="o">.</span><span class="n">edge</span><span class="p">[</span><span class="n">u</span><span class="p">][</span><span class="n">v</span><span class="p">][</span><span class="s1">&#39;type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;core_aggregation&#39;</span>
    <span class="k">for</span> <span class="n">u</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_core</span><span class="p">,</span> <span class="n">n_core</span> <span class="o">+</span> <span class="n">n_aggregation</span><span class="p">):</span>
        <span class="n">topo</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">u</span><span class="p">][</span><span class="s1">&#39;tier&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;aggregation&#39;</span>
        <span class="n">topo</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">u</span><span class="p">][</span><span class="s1">&#39;type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;switch&#39;</span>
        <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_edge</span><span class="p">):</span>
            <span class="n">v</span> <span class="o">=</span> <span class="n">topo</span><span class="o">.</span><span class="n">number_of_nodes</span><span class="p">()</span>
            <span class="n">topo</span><span class="o">.</span><span class="n">add_node</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
            <span class="n">topo</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">v</span><span class="p">][</span><span class="s1">&#39;tier&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;edge&#39;</span>
            <span class="n">topo</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">v</span><span class="p">][</span><span class="s1">&#39;type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;switch&#39;</span>
            <span class="n">topo</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="s1">&#39;aggregation_edge&#39;</span><span class="p">)</span>
    <span class="n">total_n_edge</span> <span class="o">=</span> <span class="n">topo</span><span class="o">.</span><span class="n">number_of_nodes</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">u</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_core</span> <span class="o">+</span> <span class="n">n_aggregation</span><span class="p">,</span> <span class="n">total_n_edge</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_hosts</span><span class="p">):</span>
            <span class="n">v</span> <span class="o">=</span> <span class="n">topo</span><span class="o">.</span><span class="n">number_of_nodes</span><span class="p">()</span>
            <span class="n">topo</span><span class="o">.</span><span class="n">add_node</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
            <span class="n">topo</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">v</span><span class="p">][</span><span class="s1">&#39;tier&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;leaf&#39;</span>
            <span class="n">topo</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">v</span><span class="p">][</span><span class="s1">&#39;type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;host&#39;</span>
            <span class="n">topo</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="s1">&#39;edge_leaf&#39;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">topo</span></div>


<div class="viewcode-block" id="bcube_topology"><a class="viewcode-back" href="../../../apidoc/generated/fnss.topologies.datacenter.bcube_topology.html#fnss.topologies.datacenter.bcube_topology">[docs]</a><span class="k">def</span> <span class="nf">bcube_topology</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">k</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return a Bcube datacenter topology, as described in [1]_:</span>

<span class="sd">    The BCube topology is a topology specifically designed for</span>
<span class="sd">    shipping-container based, modular data centers. A BCube topology comprises</span>
<span class="sd">    hosts with multiple network interfaces connected to commodity switches. It</span>
<span class="sd">    has the peculiar characteristic that switches are never directly connected</span>
<span class="sd">    to each other and hosts are used also for packet forwarding. This</span>
<span class="sd">    topology is defined as a recursive structure. A :math:`Bcube_0` is composed</span>
<span class="sd">    of n hosts connected to an n-port switch. A :math:`Bcube_1` is composed</span>
<span class="sd">    of n :math:`Bcube_0` connected to n n-port switches. A :math:`Bcube_k` is</span>
<span class="sd">    composed of n :math:`Bcube_{k-1}` connected to :math:`n^k` n-port switches.</span>

<span class="sd">    This topology comprises:</span>
<span class="sd">     * :math:`n^(k+1)` hosts, each of them connected to :math:`k+1` switches</span>
<span class="sd">     * :math:`n*(k+1)` switches, each of them having n ports</span>

<span class="sd">    Each node has an attribute type which can either be *switch* or *host*</span>
<span class="sd">    and an attribute *level* which specifies at what level of the Bcube</span>
<span class="sd">    hierarchy it is located.</span>

<span class="sd">    Each edge also has the attribute *level*.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    k : int</span>
<span class="sd">        The level of Bcube</span>
<span class="sd">    n : int</span>
<span class="sd">        The number of host per :math:`Bcube_0`</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    topology : DatacenterTopology</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] C. Guo, G. Lu, D. Li, H. Wu, X. Zhang, Y. Shi, C. Tian, Y. Zhang,</span>
<span class="sd">       and S. Lu.  BCube: a high performance, host-centric network</span>
<span class="sd">       architecture for modular data centers. Proceedings of the ACM SIGCOMM</span>
<span class="sd">       2009 conference on Data communication (SIGCOMM &#39;09). ACM, New York, NY,</span>
<span class="sd">       USA. http://doi.acm.org/10.1145/1592568.1592577</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Validate input arguments</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span> <span class="ow">or</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;k and n arguments must be of int type&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Invalid n parameter. It should be &gt;= 1&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Invalid k parameter. It should be &gt;= 0&quot;</span><span class="p">)</span>

    <span class="n">topo</span> <span class="o">=</span> <span class="n">DatacenterTopology</span><span class="p">(</span><span class="nb">type</span><span class="o">=</span><span class="s1">&#39;bcube&#39;</span><span class="p">)</span>
    <span class="n">topo</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;bcube_topology(</span><span class="si">%d</span><span class="s2">,</span><span class="si">%d</span><span class="s2">)&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span>

    <span class="c1"># add hosts</span>
    <span class="n">n_hosts</span> <span class="o">=</span> <span class="n">n</span> <span class="o">**</span> <span class="p">(</span><span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">topo</span><span class="o">.</span><span class="n">add_nodes_from</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">n_hosts</span><span class="p">),</span> <span class="nb">type</span><span class="o">=</span><span class="s1">&#39;host&#39;</span><span class="p">)</span>

    <span class="c1"># add all layers of switches and connect them to hosts</span>
    <span class="k">for</span> <span class="n">level</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
        <span class="c1"># i is the horizontal position of a switch a specific level</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span> <span class="o">**</span> <span class="n">k</span><span class="p">):</span>
            <span class="n">u</span> <span class="o">=</span> <span class="n">topo</span><span class="o">.</span><span class="n">number_of_nodes</span><span class="p">()</span>
            <span class="c1"># add switch at given level</span>
            <span class="n">topo</span><span class="o">.</span><span class="n">add_node</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="n">level</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="s1">&#39;switch&#39;</span><span class="p">)</span>
            <span class="n">hosts</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">i</span> <span class="o">+</span> <span class="n">n</span> <span class="o">**</span> <span class="p">(</span><span class="n">level</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span> <span class="n">n</span> <span class="o">**</span> <span class="n">level</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">hosts</span><span class="p">:</span>
                <span class="n">topo</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="n">level</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">topo</span></div>


<div class="viewcode-block" id="fat_tree_topology"><a class="viewcode-back" href="../../../apidoc/generated/fnss.topologies.datacenter.fat_tree_topology.html#fnss.topologies.datacenter.fat_tree_topology">[docs]</a><span class="k">def</span> <span class="nf">fat_tree_topology</span><span class="p">(</span><span class="n">k</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return a fat tree datacenter topology, as described in [1]_</span>

<span class="sd">    A fat tree topology built using k-port switches can support up to</span>
<span class="sd">    :math:`(k^3)/4` hosts. This topology comprises k pods with two layers of</span>
<span class="sd">    :math:`k/2` switches each. In each pod, each aggregation switch is</span>
<span class="sd">    connected to all the :math:`k/2` edge switches and each edge switch is</span>
<span class="sd">    connected to :math:`k/2` hosts. There are :math:`(k/2)^2` core switches,</span>
<span class="sd">    each of them connected to one aggregation switch per pod.</span>

<span class="sd">    Each node has three attributes:</span>
<span class="sd">     * type: can either be *switch* or *host*</span>
<span class="sd">     * tier: can either be *core*, *aggregation*, *edge* or *leaf*. Nodes in</span>
<span class="sd">     * pod: the pod id in which the node is located, unless it is a core switch</span>
<span class="sd">       the leaf tier are only host, while all core, aggregation and edge</span>
<span class="sd">       nodes are switches.</span>

<span class="sd">    Each edge has an attribute type as well which can either be *core_edge* if</span>
<span class="sd">    it connects a core and an aggregation switch, *aggregation_edge*, if it</span>
<span class="sd">    connects an aggregation and a core switch or *edge_leaf* if it connects an</span>
<span class="sd">    edge switch to a host.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    k : int</span>
<span class="sd">        The number of ports of the switches</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    topology : DatacenterTopology</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] M. Al-Fares, A. Loukissas, and A. Vahdat. A scalable, commodity</span>
<span class="sd">       data center network architecture. Proceedings of the ACM SIGCOMM 2008</span>
<span class="sd">       conference on Data communication (SIGCOMM &#39;08). ACM, New York, NY, USA</span>
<span class="sd">       http://doi.acm.org/10.1145/1402958.1402967</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># validate input arguments</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;k argument must be of int type&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="mi">1</span> <span class="ow">or</span> <span class="n">k</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;k must be a positive even integer&#39;</span><span class="p">)</span>

    <span class="n">topo</span> <span class="o">=</span> <span class="n">DatacenterTopology</span><span class="p">(</span><span class="nb">type</span><span class="o">=</span><span class="s1">&#39;fat_tree&#39;</span><span class="p">)</span>
    <span class="n">topo</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;fat_tree_topology(</span><span class="si">%d</span><span class="s2">)&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">k</span><span class="p">)</span>

    <span class="c1"># Create core nodes</span>
    <span class="n">n_core</span> <span class="o">=</span> <span class="p">(</span><span class="n">k</span> <span class="o">//</span> <span class="mi">2</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span>
    <span class="n">topo</span><span class="o">.</span><span class="n">add_nodes_from</span><span class="p">([</span><span class="n">v</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">n_core</span><span class="p">))],</span>
                        <span class="n">layer</span><span class="o">=</span><span class="s1">&#39;core&#39;</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="s1">&#39;switch&#39;</span><span class="p">)</span>

    <span class="c1"># Create aggregation and edge nodes and connect them</span>
    <span class="k">for</span> <span class="n">pod</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">k</span><span class="p">):</span>
        <span class="n">aggr_start_node</span> <span class="o">=</span> <span class="n">topo</span><span class="o">.</span><span class="n">number_of_nodes</span><span class="p">()</span>
        <span class="n">aggr_end_node</span> <span class="o">=</span> <span class="n">aggr_start_node</span> <span class="o">+</span> <span class="n">k</span> <span class="o">//</span> <span class="mi">2</span>
        <span class="n">edge_start_node</span> <span class="o">=</span> <span class="n">aggr_end_node</span>
        <span class="n">edge_end_node</span> <span class="o">=</span> <span class="n">edge_start_node</span> <span class="o">+</span> <span class="n">k</span> <span class="o">//</span> <span class="mi">2</span>
        <span class="n">aggr_nodes</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="n">aggr_start_node</span><span class="p">,</span> <span class="n">aggr_end_node</span><span class="p">)</span>
        <span class="n">edge_nodes</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="n">edge_start_node</span><span class="p">,</span> <span class="n">edge_end_node</span><span class="p">)</span>
        <span class="n">topo</span><span class="o">.</span><span class="n">add_nodes_from</span><span class="p">(</span><span class="n">aggr_nodes</span><span class="p">,</span> <span class="n">layer</span><span class="o">=</span><span class="s1">&#39;aggregation&#39;</span><span class="p">,</span>
                            <span class="nb">type</span><span class="o">=</span><span class="s1">&#39;switch&#39;</span><span class="p">,</span> <span class="n">pod</span><span class="o">=</span><span class="n">pod</span><span class="p">)</span>
        <span class="n">topo</span><span class="o">.</span><span class="n">add_nodes_from</span><span class="p">(</span><span class="n">edge_nodes</span><span class="p">,</span> <span class="n">layer</span><span class="o">=</span><span class="s1">&#39;edge&#39;</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="s1">&#39;switch&#39;</span><span class="p">,</span> <span class="n">pod</span><span class="o">=</span><span class="n">pod</span><span class="p">)</span>
        <span class="n">topo</span><span class="o">.</span><span class="n">add_edges_from</span><span class="p">([(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">u</span> <span class="ow">in</span> <span class="n">aggr_nodes</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">edge_nodes</span><span class="p">],</span>
                            <span class="nb">type</span><span class="o">=</span><span class="s1">&#39;aggregation_edge&#39;</span><span class="p">)</span>
    <span class="c1"># Connect core switches to aggregation switches</span>
    <span class="k">for</span> <span class="n">core_node</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_core</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">pod</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">k</span><span class="p">):</span>
            <span class="n">aggr_node</span> <span class="o">=</span> <span class="n">n_core</span> <span class="o">+</span> <span class="p">(</span><span class="n">core_node</span> <span class="o">//</span> <span class="p">(</span><span class="n">k</span> <span class="o">//</span> <span class="mi">2</span><span class="p">))</span> <span class="o">+</span> <span class="p">(</span><span class="n">k</span> <span class="o">*</span> <span class="n">pod</span><span class="p">)</span>
            <span class="n">topo</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="n">core_node</span><span class="p">,</span> <span class="n">aggr_node</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="s1">&#39;core_aggregation&#39;</span><span class="p">)</span>
    <span class="c1"># Create hosts and connect them to edge switches</span>
    <span class="k">for</span> <span class="n">u</span> <span class="ow">in</span> <span class="p">[</span><span class="n">v</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">topo</span><span class="o">.</span><span class="n">nodes_iter</span><span class="p">()</span> <span class="k">if</span> <span class="n">topo</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">v</span><span class="p">][</span><span class="s1">&#39;layer&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;edge&#39;</span><span class="p">]:</span>
        <span class="n">leaf_nodes</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="n">topo</span><span class="o">.</span><span class="n">number_of_nodes</span><span class="p">(),</span>
                           <span class="n">topo</span><span class="o">.</span><span class="n">number_of_nodes</span><span class="p">()</span> <span class="o">+</span> <span class="n">k</span> <span class="o">//</span> <span class="mi">2</span><span class="p">)</span>
        <span class="n">topo</span><span class="o">.</span><span class="n">add_nodes_from</span><span class="p">(</span><span class="n">leaf_nodes</span><span class="p">,</span> <span class="n">layer</span><span class="o">=</span><span class="s1">&#39;leaf&#39;</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="s1">&#39;host&#39;</span><span class="p">,</span>
                            <span class="n">pod</span><span class="o">=</span><span class="n">topo</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">u</span><span class="p">][</span><span class="s1">&#39;pod&#39;</span><span class="p">])</span>
        <span class="n">topo</span><span class="o">.</span><span class="n">add_edges_from</span><span class="p">([(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">leaf_nodes</span><span class="p">],</span> <span class="nb">type</span><span class="o">=</span><span class="s1">&#39;edge_leaf&#39;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">topo</span></div>
</pre></div>

          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../../index.html">FNSS 0.7.0 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../../index.html" >Module code</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2012-2018, Lorenzo Saino, Cosmin Cocora.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.6.5.
    </div>
  </body>
</html>