# coding=UTF-8
from __future__ import unicode_literals
from django.conf import settings
from django.http import HttpResponse, Http404
from django.urls import resolve
from django.db.models import QuerySet
from cubane.lib.excerpt import excerpt_from_text
from cubane.lib.file import sizeof_fmt
from cubane.lib.filelock import FileLock
from cubane.lib.verbose import out
from cubane.lib.url import get_filepath_from_url
from datetime import datetime
import time
import os


MAX_ITERATION_STEPS = 10


class CacheGenerator(object):
    """
    Uses the CMS and the cache system in order to generate a cached version
    of the website.
    """
    def __init__(self, cms, cache):
        self.cms = cms
        self.cache = cache


    @property
    def cache_context(self):
        """
        Return the current cache context.
        """
        return self.cache.context


    def info(self, filepath, status, verbose=False):
        """
        Print information about the processed file and its status.
        """
        if verbose and not settings.TEST:
            if not filepath.startswith('/'):
                 filepath = '/' + filepath

            print '%-65s  [%s]' % (
                excerpt_from_text(filepath, length=62, prefix=True),
                status
            )


    def add_to_cache(self, filepath, mtime, changed, content, verbose=False):
        """
        Add item to cache.
        """
        size_bytes, changed = self.cache.add(
            filepath,
            mtime,
            changed,
            content,
            minify_html=True
        )

        self.info(
            filepath,
            sizeof_fmt(size_bytes) if changed else 'NOT CHANGED',
            verbose
        )


    def content_changed(self, template_context, filepath, updated_on=None):
        """
        Determine if the page with the given template context has changed
        since the last time we cached the resource.
        """
        # if we are rending for the cache system, materialise all querysets
        # in the template context, so that we can scan for last modification
        # timestamps of entities that are involved in rendering
        self.materialise_template_context(template_context)
        new_mtime = self.get_updated_on_from_template_context(
            template_context,
            updated_on
        )

        # determine current last-mod. time of current cached resource
        mtime = self.cache.get_mtime(filepath)

        # if the new last modification timestamp is NEWER than the given
        # current mtime, we need to re-render the content
        render_required = new_mtime is None or mtime is None or new_mtime > mtime
        return render_required, new_mtime


    def process_page(self, page, verbose=False):
        """
        Process given page for the cache system.
        """
        return self._process_page_for_cache(page=page, verbose=verbose)


    def process_page_by_slug(self, slug, verbose=False):
        """
        Process a cms page by its given slug.
        """
        return self._process_page_for_cache(slug=slug, verbose=verbose)


    def process_page_by_url(self, url_name, args=[], verbose=False, filepath=None):
        """
        Process cms content by executing the given url with the given url arguments.
        """
        if filepath is None:
            filepath = get_filepath_from_url(url_name, args)

        return self._process_page_for_cache(filepath=filepath, url=url_name, args=args, verbose=verbose)


    def publish(self, verbose=False):
        """
        Publishes all cms content. Two processes cannot publish at the same
        time and the process may be interrupted as soon as another process
        attempts to invalidate, clear the cache and publish again.
        """
        return self._execute_after_publish_terminated(
            self._publish_content, verbose
        )


    def invalidate(self, verbose=False):
        """
        Invalidates all CMS content from the cache which was generated by
        calling publish(). Two processes cannot invalidate at the same time and
        we are waiting for publish() to terminate instantly before we invalidate
        the cache.
        """
        return self._execute_after_publish_terminated(
            self._invalidate_content, verbose
        )


    def clear_cache(self, verbose=False):
        """
        Clears the CMS cache entirely. If the cache is currently publishing,
        we wait for publish() to terminate instantly and then clear the cache.
        Two instances cannot clear the cache at the same time.
        """
        return self._execute_after_publish_terminated(
            self._clear_cache_content, verbose
        )


    def materialise_template_context(self, template_context, level=0):
        """
        Find all QuerySet instances in the template context and materialise it
        (in-place).
        """
        if level > MAX_ITERATION_STEPS:
            return template_context

        if template_context is None:
            return {}

        if isinstance(template_context, dict):
            for k, v in template_context.items():
                if isinstance(v, QuerySet):
                    template_context[k] = list(v)
                elif isinstance(v, dict):
                    template_context[k] = self.materialise_template_context(v, level + 1)

        return template_context


    def get_updated_on_from_template_context(self, template_context, updated_on):
        """
        Return the last modification timestamp that applies for the given
        template context. The last modification timestamp is determined by a
        number of circumstances. For example the last deployment timestamp and
        the last modification timestamp for CMS settings are included in the
        decision making process as well as any entity that may be found within
        the given template context.
        """
        def _cmp_timestamp(item, updated_on):
            if hasattr(item, 'updated_on'):
                _updated_on = item.updated_on
                if _updated_on is not None:
                    if isinstance(_updated_on, datetime):
                        if updated_on is None or _updated_on > updated_on:
                            updated_on = _updated_on
            return updated_on


        def _collect(d, updated_on, level=0):
            if level > MAX_ITERATION_STEPS:
                return updated_on

            if isinstance(d, dict):
                for k, v in d.items():
                    if isinstance(v, list):
                        for item in v:
                            updated_on = _collect(item, updated_on, level + 1)
                    elif isinstance(v, dict):
                        updated_on = _collect(v, updated_on, level + 1)
                    elif k == 'updated_on' and v is not None and isinstance(v, datetime):
                        if updated_on is None or v > updated_on:
                            updated_on = v
                    else:
                        updated_on = _cmp_timestamp(v, updated_on)
            else:
                updated_on = _cmp_timestamp(d, updated_on)

            return updated_on


        # scan through the template context and find any newer last-mod.
        # timestamp of any depending objects (newer than the timestamp we
        # were given to begin with)
        updated_on = _collect(template_context, updated_on)

        # settings
        if self.cms.settings:
            # if cms settings last-mod. timestamp is newer, take this one
            if updated_on is None or (self.cms.settings.updated_on is not None and self.cms.settings.updated_on > updated_on):
                updated_on = self.cms.settings.updated_on

            # if we deleted any entity, take such timestamp into consideration
            # as well
            if updated_on is None or (self.cms.settings.entity_deleted_on is not None and self.cms.settings.entity_deleted_on > updated_on):
                updated_on = self.cms.settings.entity_deleted_on

        # if the system has been deployed after the lastmod timestamp we have
        # so far, use the deployment timestamp instead
        deploy_timestamp = self.cms.deploy_timestamp
        if deploy_timestamp:
            if updated_on is None or (deploy_timestamp is not None and deploy_timestamp > updated_on):
                updated_on = deploy_timestamp

        # ignore millisecond component, since file's last-mod timestamp would
        # most likely not have this resolution.
        updated_on = updated_on.replace(microsecond=0)

        return updated_on


    def _publish_content(self, verbose=False):
        """
        Publish cms content.
        """
        from cubane.cms.views import fake_request

        # add all pages
        start = time.time()
        for page in self.cms.get_pages():
            if self.quit:
                break

            # determine type of page
            is_homepage = self.cms.settings.homepage_id == page.id
            is_contact_page = self.cms.settings.contact_page_id == page.id

            # skip contact page if CSRF is enabled, since we would not
            # be able to generate a dynamic CSRF token if this page is cached
            if 'django.middleware.csrf.CsrfViewMiddleware' in settings.MIDDLEWARE_CLASSES and is_contact_page:
                continue

            # add page
            self.process_page(page=page, verbose=verbose)

            # add paginated pages
            entity_model = page.get_entity_model()
            if entity_model and self.cms.settings.paging_enabled_for(entity_model):
                # get all available pages, starting with page number 2
                # and continue as long as we do not get 404...
                i = 2
                has_pages = True
                # adding an upper bound of max_pages
                child_page_count = entity_model.objects.count()
                while has_pages and child_page_count > 0:
                    page_part = 'page-%d' % i
                    slug = '/%s/%s/' % (page.slug, page_part)

                    # render page
                    has_pages = self.process_page_by_slug(slug=slug, verbose=verbose)
                    i += 1
                    child_page_count -= 1

        # add all child pages
        for model in self.cms.get_child_page_models():
            if self.quit:
                break

            # if a page is assigned to this child_page_model
            pages = self.cms.get_pages().filter(entity_type=model.__name__)
            pages = self.cms.filter_out_childpages_on_sitemap(pages)
            if pages.count() > 0:
                for child_page in self.cms.filter_out_childpages_on_sitemap(self.cms.get_child_pages_for_model(model)):
                    page = child_page.page

                    # ignore child page with parent reference
                    if page == None:
                        continue

                    # ignore, if parent page does not support entity type
                    if page.entity_type != model.__name__:
                        continue

                    # add child page to cache
                    self.process_page(page=child_page, verbose=verbose)

        # give other modules a place to do something with the cache
        self.cms.on_generate_cache(self, verbose)

        # add non-cms pages
        for custom_page in self.cms.custom_sitemap.cached_pages():
            if self.quit: break

            local_url = custom_page.local_url
            request = fake_request(local_url, self.cms)
            view, args, kwargs = resolve(local_url)
            kwargs['request'] = request

            # render page
            try:
                response = view(*args, **kwargs)
                # generate cache entry
                if response and response.status_code == 200:
                    path = os.path.join(local_url.lstrip('/'), 'index.html')
                    self.add_to_cache(
                        path,
                        custom_page.lastmod,
                        None,
                        response.content,
                        verbose=verbose
                    )
            except Http404:
                pass

        # generate cache index file, even if we are forced to quit...
        self.cache.write()
        self.cache.cleanup()

        # present a message that we got terminated by another process
        if self.quit:
            out('- TERMINATED -', verbose=verbose)

        end = time.time()
        return (self.cache.items, self.cache.size, end - start)


    def _process_page_for_cache(self, page=None, slug=None, url=None, args=[], filepath=None, verbose=False):
        """
        Process the given page for the cache system. The page will only be
        actually rendered if the template context differs from the previous
        template context.
        """
        # aquire publish lock in order to generate cache content. If we
        # cannot aquire the lock, then we simply terminate the cache generation
        # instantly, since someone else is going to invalidate, clear or
        # re-generate the cache
        if self.quit:
            return False

        if not self.terminate_lock.acquire(wait=False):
            self.quit = True
            return False

        try:
            from cubane.cms.views import RenderResponse

            # render page
            try:
                if page:
                    render_response = self.cms.render_page(page, cache_generator=self)
                elif slug:
                    render_response = self.cms.render_page_by_slug(slug, cache_generator=self)
                elif url and filepath:
                    render_response = self.cms.render_page_by_url(filepath, url, args, cache_generator=self)
                else:
                    raise ValueError('Unable to process content for cache system. No valid content given.')
            except Http404:
                return False

            # do not accept a response that is NOT a RenderResult, for example
            # an HttpResponse or redirect...
            if not isinstance(render_response, RenderResponse):
                self.info(filepath, 'NOT CACHEABLE', verbose)
                return False

            # do not accept response code other than 200 (OK)
            if not render_response or render_response.response.status_code != 200:
                return False

            # add content to cache
            self.add_to_cache(
                render_response.filepath,
                render_response.mtime,
                render_response.changed,
                render_response.content,
                verbose
            )
        finally:
            self.terminate_lock.release()

        return True


    def _invalidate_content(self, verbose=False):
        """
        Invalidate cms content.
        """
        if not self.terminate_lock.acquire(wait=False):
            return 0

        try:
            return self.cache.invalidate(verbose)
        finally:
            self.terminate_lock.release()


    def _clear_cache_content(self, verbose=False):
        """
        Clear cache content.
        """
        if not self.terminate_lock.acquire(wait=False):
            return 0

        try:
            return self.cache.clear(verbose)
        finally:
            self.terminate_lock.release()


    def _get_lock(self, usage):
        """
        Return a file lock that is unique based on the domain name for this
        website and the given usage string, which should indicate the usage of the
        lock.
        """
        return FileLock.temp(settings.DOMAIN_NAME, usage)


    def _execute_after_publish_terminated(self, func, *args, **kwargs):
        """
        Execute the given func() only after any publish process that may be
        executing right now is terminated successfully.
        """
        lock = self._get_lock('cache')
        try:
            # create lock for signaling publish termination
            self.terminate_lock = self._get_lock('cache-terminate')
            self.quit = False
            wait_for_termination = False

            # some other cache operation is currently executing ->
            # signal running process to terminate immediatly...
            if not lock.acquire(wait=False):
                wait_for_termination = True
                self.terminate_lock.acquire()

            # wait for publish() to terminate...
            lock.acquire()

            # release publish termination lock
            if wait_for_termination:
                self.terminate_lock.release()

            # publish content
            return func(*args, **kwargs)
        finally:
            lock.release()