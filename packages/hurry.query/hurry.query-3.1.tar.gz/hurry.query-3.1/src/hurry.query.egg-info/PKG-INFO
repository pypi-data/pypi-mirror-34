Metadata-Version: 1.1
Name: hurry.query
Version: 3.1
Summary: Higher level query system for the zope.catalog
Home-page: http://pypi.python.org/pypi/hurry.query
Author: Infrae
Author-email: faassen@startifact.com
License: ZPL 2.1
Description-Content-Type: UNKNOWN
Description: Hurry Query
        ===========
        
        The hurry query system for the zope.catalog builds on its catalog
        indexes, as well as the indexes in zc.catalog. It is in part inspired
        by AdvancedQuery for Zope 2 by Dieter Maurer, though has an independent
        origin.
        
        .. contents::
        
        Setup
        -----
        
        Let&#x27;s define a simple content object. First its interface::
        
          &gt;&gt;&gt; from zope.interface import Interface, Attribute, implementer
          &gt;&gt;&gt; class IContent(Interface):
          ...     f1 = Attribute(&#x27;f1&#x27;)
          ...     f2 = Attribute(&#x27;f2&#x27;)
          ...     f3 = Attribute(&#x27;f3&#x27;)
          ...     f4 = Attribute(&#x27;f4&#x27;)
          ...     t1 = Attribute(&#x27;t1&#x27;)
          ...     t2 = Attribute(&#x27;t2&#x27;)
        
        And its implementation::
        
          &gt;&gt;&gt; import functools
          &gt;&gt;&gt; from zope.container.contained import Contained
          &gt;&gt;&gt; @functools.total_ordering
          ... @implementer(IContent)
          ... class Content(Contained):
          ...     def __init__(self, id, f1=&#x27;&#x27;, f2=&#x27;&#x27;, f3=&#x27;&#x27;, f4=&#x27;&#x27;, t1=&#x27;&#x27;, t2=&#x27;&#x27;):
          ...         self.id = id
          ...         self.f1 = f1
          ...         self.f2 = f2
          ...         self.f3 = f3
          ...         self.f4 = f4
          ...         self.t1 = t1
          ...         self.t2 = t2
          ...     def __lt__(self, other):
          ...         return self.id &lt; other.id
          ...     def __eq__(self, other):
          ...         return self.id == other.id
          ...     def __repr__(self):
          ...         return &#x27;&lt;Content &quot;{}&quot;&gt;&#x27;.format(self.id)
        
        The id attribute is just so we can identify objects we find again
        easily. By including the __cmp__ method we make sure search results
        can be stably sorted.
        
        We use a fake int id utility here so we can test independent of
        the full-blown zope environment::
        
          &gt;&gt;&gt; from zope import interface
          &gt;&gt;&gt; import zope.intid.interfaces
          &gt;&gt;&gt; @interface.implementer(zope.intid.interfaces.IIntIds)
          ... class DummyIntId(object):
          ...     MARKER = &#x27;__dummy_int_id__&#x27;
          ...     def __init__(self):
          ...         self.counter = 0
          ...         self.data = {}
          ...     def register(self, obj):
          ...         intid = getattr(obj, self.MARKER, None)
          ...         if intid is None:
          ...             setattr(obj, self.MARKER, self.counter)
          ...             self.data[self.counter] = obj
          ...             intid = self.counter
          ...             self.counter += 1
          ...         return intid
          ...     def getId(self, obj):
          ...         return getattr(obj, self.MARKER)
          ...     def getObject(self, intid):
          ...         return self.data[intid]
          ...     def __iter__(self):
          ...         return iter(self.data)
          &gt;&gt;&gt; intid = DummyIntId()
          &gt;&gt;&gt; from zope.component import provideUtility
          &gt;&gt;&gt; provideUtility(intid, zope.intid.interfaces.IIntIds)
        
        Now let&#x27;s register a catalog::
        
          &gt;&gt;&gt; from zope.catalog.interfaces import ICatalog
          &gt;&gt;&gt; from zope.catalog.catalog import Catalog
          &gt;&gt;&gt; catalog = Catalog()
          &gt;&gt;&gt; provideUtility(catalog, ICatalog, &#x27;catalog1&#x27;)
        
        And set it up with various indexes::
        
          &gt;&gt;&gt; from zope.catalog.field import FieldIndex
          &gt;&gt;&gt; from zope.catalog.text import TextIndex
          &gt;&gt;&gt; catalog[&#x27;f1&#x27;] = FieldIndex(&#x27;f1&#x27;, IContent)
          &gt;&gt;&gt; catalog[&#x27;f2&#x27;] = FieldIndex(&#x27;f2&#x27;, IContent)
          &gt;&gt;&gt; catalog[&#x27;f3&#x27;] = FieldIndex(&#x27;f3&#x27;, IContent)
          &gt;&gt;&gt; catalog[&#x27;f4&#x27;] = FieldIndex(&#x27;f4&#x27;, IContent)
          &gt;&gt;&gt; catalog[&#x27;t1&#x27;] = TextIndex(&#x27;t1&#x27;, IContent)
          &gt;&gt;&gt; catalog[&#x27;t2&#x27;] = TextIndex(&#x27;t2&#x27;, IContent)
        
        Now let&#x27;s create some objects so that they&#x27;ll be cataloged::
        
          &gt;&gt;&gt; content = [
          ... Content(1, &#x27;a&#x27;, &#x27;b&#x27;, &#x27;d&#x27;),
          ... Content(2, &#x27;a&#x27;, &#x27;c&#x27;),
          ... Content(3, &#x27;X&#x27;, &#x27;c&#x27;),
          ... Content(4, &#x27;a&#x27;, &#x27;b&#x27;, &#x27;e&#x27;),
          ... Content(5, &#x27;X&#x27;, &#x27;b&#x27;, &#x27;e&#x27;),
          ... Content(6, &#x27;Y&#x27;, &#x27;Z&#x27;)]
        
        And catalog them now::
        
          &gt;&gt;&gt; for entry in content:
          ...     catalog.index_doc(intid.register(entry), entry)
        
        Now let&#x27;s register a query utility::
        
          &gt;&gt;&gt; from hurry.query.query import Query
          &gt;&gt;&gt; from hurry.query.interfaces import IQuery
          &gt;&gt;&gt; provideUtility(Query(), IQuery)
        
        Set up some code to make querying and display the result
        easy::
        
          &gt;&gt;&gt; from zope.component import getUtility
          &gt;&gt;&gt; from hurry.query.interfaces import IQuery
          &gt;&gt;&gt; def displayQuery(q, context=None):
          ...     query = getUtility(IQuery)
          ...     r = query.searchResults(q, context)
          ...     return [e.id for e in sorted(list(r))]
        
        FieldIndex Queries
        ------------------
        
        We can query for all objects indexed in this index::
        
          &gt;&gt;&gt; from hurry.query import All
          &gt;&gt;&gt; f1 = (&#x27;catalog1&#x27;, &#x27;f1&#x27;)
          &gt;&gt;&gt; displayQuery(All(f1))
          [1, 2, 3, 4, 5, 6]
        
        Now for a query where f1 equals a::
        
          &gt;&gt;&gt; from hurry.query import Eq
          &gt;&gt;&gt; f1 = (&#x27;catalog1&#x27;, &#x27;f1&#x27;)
          &gt;&gt;&gt; displayQuery(Eq(f1, &#x27;a&#x27;))
          [1, 2, 4]
        
        Not equals (this is more efficient than the generic ~ operator)::
        
          &gt;&gt;&gt; from hurry.query import NotEq
          &gt;&gt;&gt; displayQuery(NotEq(f1, &#x27;a&#x27;))
          [3, 5, 6]
        
        Testing whether a field is in a set::
        
          &gt;&gt;&gt; from hurry.query import In
          &gt;&gt;&gt; displayQuery(In(f1, [&#x27;a&#x27;, &#x27;X&#x27;]))
          [1, 2, 3, 4, 5]
        
        Whether documents are in a specified range::
        
          &gt;&gt;&gt; from hurry.query import Between
          &gt;&gt;&gt; displayQuery(Between(f1, &#x27;X&#x27;, &#x27;Y&#x27;))
          [3, 5, 6]
        
        You can leave out one end of the range::
        
          &gt;&gt;&gt; displayQuery(Between(f1, &#x27;X&#x27;, None)) # &#x27;X&#x27; &lt; &#x27;a&#x27;
          [1, 2, 3, 4, 5, 6]
          &gt;&gt;&gt; displayQuery(Between(f1, None, &#x27;X&#x27;))
          [3, 5]
        
        You can also use greater-equals and lesser-equals for the same purpose::
        
          &gt;&gt;&gt; from hurry.query import Ge, Le
          &gt;&gt;&gt; displayQuery(Ge(f1, &#x27;X&#x27;))
          [1, 2, 3, 4, 5, 6]
          &gt;&gt;&gt; displayQuery(Le(f1, &#x27;X&#x27;))
          [3, 5]
        
        It&#x27;s also possible to use not with the ~ operator::
        
          &gt;&gt;&gt; displayQuery(~Eq(f1, &#x27;a&#x27;))
          [3, 5, 6]
        
        Using and (&amp;)::
        
          &gt;&gt;&gt; f2 = (&#x27;catalog1&#x27;, &#x27;f2&#x27;)
          &gt;&gt;&gt; displayQuery(Eq(f1, &#x27;a&#x27;) &amp; Eq(f2, &#x27;b&#x27;))
          [1, 4]
        
        Using or (|)::
        
          &gt;&gt;&gt; displayQuery(Eq(f1, &#x27;a&#x27;) | Eq(f2, &#x27;b&#x27;))
          [1, 2, 4, 5]
        
        These can be chained::
        
          &gt;&gt;&gt; displayQuery(Eq(f1, &#x27;a&#x27;) &amp; Eq(f2, &#x27;b&#x27;) &amp; Between(f1, &#x27;a&#x27;, &#x27;b&#x27;))
          [1, 4]
          &gt;&gt;&gt; displayQuery(Eq(f1, &#x27;a&#x27;) | Eq(f1, &#x27;X&#x27;) | Eq(f2, &#x27;b&#x27;))
          [1, 2, 3, 4, 5]
        
        And nested::
        
          &gt;&gt;&gt; displayQuery((Eq(f1, &#x27;a&#x27;) | Eq(f1, &#x27;X&#x27;)) &amp; (Eq(f2, &#x27;b&#x27;) | Eq(f2, &#x27;c&#x27;)))
          [1, 2, 3, 4, 5]
        
        &quot;and&quot; and &quot;or&quot; can also be spelled differently::
        
          &gt;&gt;&gt; from hurry.query import And, Or
          &gt;&gt;&gt; displayQuery(And(Eq(f1, &#x27;a&#x27;), Eq(f2, &#x27;b&#x27;)))
          [1, 4]
          &gt;&gt;&gt; displayQuery(Or(Eq(f1, &#x27;a&#x27;), Eq(f2, &#x27;b&#x27;)))
          [1, 2, 4, 5]
        
        Combination of In and &amp;
        -----------------------
        
        A combination of &#x27;In&#x27; and &#x27;&amp;&#x27;::
        
          &gt;&gt;&gt; displayQuery(In(f1, [&#x27;a&#x27;, &#x27;X&#x27;, &#x27;Y&#x27;, &#x27;Z&#x27;]))
          [1, 2, 3, 4, 5, 6]
          &gt;&gt;&gt; displayQuery(In(f1, [&#x27;Z&#x27;]))
          []
          &gt;&gt;&gt; displayQuery(In(f1, [&#x27;a&#x27;, &#x27;X&#x27;, &#x27;Y&#x27;, &#x27;Z&#x27;]) &amp; In(f1, [&#x27;Z&#x27;]))
          []
        
        
        SetIndex queries
        ----------------
        
        The SetIndex is defined in zc.catalog.
        
          &gt;&gt;&gt; from hurry.query import set
        
        Let&#x27;s make a catalog which uses it::
        
          &gt;&gt;&gt; intid = DummyIntId()
          &gt;&gt;&gt; provideUtility(intid, zope.intid.interfaces.IIntIds)
          &gt;&gt;&gt; from zope.catalog.interfaces import ICatalog
          &gt;&gt;&gt; from zope.catalog.catalog import Catalog
          &gt;&gt;&gt; catalog = Catalog()
          &gt;&gt;&gt; provideUtility(catalog, ICatalog, &#x27;catalog1&#x27;)
          &gt;&gt;&gt; from zc.catalog.catalogindex import SetIndex
          &gt;&gt;&gt; catalog[&#x27;f1&#x27;] = SetIndex(&#x27;f1&#x27;, IContent)
          &gt;&gt;&gt; catalog[&#x27;f2&#x27;] = FieldIndex(&#x27;f2&#x27;, IContent)
        
        First let&#x27;s set up some new data::
        
          &gt;&gt;&gt; content = [
          ... Content(1, [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;], 1),
          ... Content(2, [&#x27;a&#x27;], 1),
          ... Content(3, [&#x27;b&#x27;], 1),
          ... Content(4, [&#x27;c&#x27;, &#x27;d&#x27;], 2),
          ... Content(5, [&#x27;b&#x27;, &#x27;c&#x27;], 2),
          ... Content(6, [&#x27;a&#x27;, &#x27;c&#x27;], 2),
          ... Content(7, [&#x27;z&#x27;], 2),
          ... Content(8, [], 2)]  # no value, so not indexed.
        
        And catalog them now::
        
          &gt;&gt;&gt; for entry in content:
          ...     catalog.index_doc(intid.register(entry), entry)
        
        We can query for all indexes objects:
        
          &gt;&gt;&gt; displayQuery(set.All(f1))
          [1, 2, 3, 4, 5, 6, 7]
        
        Now do a a &#x27;any of&#x27; query, which returns all documents that
        contain any of the values listed::
        
          &gt;&gt;&gt; displayQuery(set.AnyOf(f1, [&#x27;a&#x27;, &#x27;c&#x27;]))
          [1, 2, 4, 5, 6]
          &gt;&gt;&gt; displayQuery(set.AnyOf(f1, [&#x27;c&#x27;, &#x27;b&#x27;]))
          [1, 3, 4, 5, 6]
          &gt;&gt;&gt; displayQuery(set.AnyOf(f1, [&#x27;a&#x27;]))
          [1, 2, 6]
        
        Do a &#x27;all of&#x27; query, which returns all documents that
        contain all of the values listed::
        
          &gt;&gt;&gt; displayQuery(set.AllOf(f1, [&#x27;a&#x27;]))
          [1, 2, 6]
          &gt;&gt;&gt; displayQuery(set.AllOf(f1, [&#x27;a&#x27;, &#x27;b&#x27;]))
          [1]
          &gt;&gt;&gt; displayQuery(set.AllOf(f1, [&#x27;a&#x27;, &#x27;c&#x27;]))
          [1, 6]
        
        The next interesting set of queries allows you to make evaluations of the
        values. For example, you can ask for all objects between a certain set of
        values:
        
          &gt;&gt;&gt; displayQuery(set.SetBetween(f1, &#x27;a&#x27;, &#x27;c&#x27;))
          [1, 2, 3, 4, 5, 6]
        
          &gt;&gt;&gt; displayQuery(set.SetBetween(f1, &#x27;a&#x27;, &#x27;c&#x27;, exclude_min=True))
          [1, 3, 4, 5, 6]
        
          &gt;&gt;&gt; displayQuery(set.SetBetween(f1, &#x27;b&#x27;, &#x27;c&#x27;, exclude_max=True))
          [1, 3, 5]
        
          &gt;&gt;&gt; displayQuery(set.SetBetween(f1, &#x27;a&#x27;, &#x27;c&#x27;,
          ...                             exclude_min=True, exclude_max=True))
          [1, 3, 5]
        
        You can also leave out one end of the range:
        
          &gt;&gt;&gt; displayQuery(set.SetBetween(f1, &#x27;c&#x27;, None))
          [1, 4, 5, 6, 7]
          &gt;&gt;&gt; displayQuery(set.SetBetween(f1, None, &#x27;c&#x27;, exclude_max=True))
          [1, 2, 3, 5, 6]
        
        You can chain set queries:
        
          &gt;&gt;&gt; displayQuery(set.AnyOf(f1, [&#x27;a&#x27;]) &amp; Eq(f2, 1))
          [1, 2]
        
        The ``set` module also supports ``zc.catalog`` extents. The first query is
        ``ExtentAny``, which returns all douments matching the extent. If the the
        extent is ``None``, all document ids are returned:
        
          &gt;&gt;&gt; displayQuery(set.ExtentAny(f1, None))
          [1, 2, 3, 4, 5, 6, 7]
        
        If we now create an extent that is only in the scope of the first four
        documents,
        
          &gt;&gt;&gt; from zc.catalog.extentcatalog import FilterExtent
          &gt;&gt;&gt; extent = FilterExtent(lambda extent, uid, obj: True)
          &gt;&gt;&gt; for i in range(4):
          ...     extent.add(i, i)
        
        then only the first four are returned:
        
          &gt;&gt;&gt; displayQuery(set.ExtentAny(f1, extent))
          [1, 2, 3, 4]
        
        The opposite query is the ``ExtentNone`` query, which returns all ids in the
        extent that are *not* in the index:
        
          &gt;&gt;&gt; id = intid.register(Content(9, &#x27;b&#x27;))
          &gt;&gt;&gt; id = intid.register(Content(10, &#x27;c&#x27;))
          &gt;&gt;&gt; id = intid.register(Content(11, &#x27;a&#x27;))
        
          &gt;&gt;&gt; extent = FilterExtent(lambda extent, uid, obj: True)
          &gt;&gt;&gt; for i in range(11):
          ...     extent.add(i, i)
        
          &gt;&gt;&gt; displayQuery(set.ExtentNone(f1, extent))
          [8, 9, 10, 11]
        
        
        ValueIndex queries
        ------------------
        
        The ``ValueIndex`` is defined in ``zc.catalog`` and provides a generalization
        of the standard field index.
        
          &gt;&gt;&gt; from hurry.query import value
        
        Let&#x27;s set up a catalog that uses this index. The ``ValueIndex`` is defined in
        ``zc.catalog``. Let&#x27;s make a catalog which uses it:
        
          &gt;&gt;&gt; intid = DummyIntId()
          &gt;&gt;&gt; provideUtility(intid, zope.intid.interfaces.IIntIds)
        
          &gt;&gt;&gt; from zope.catalog.interfaces import ICatalog
          &gt;&gt;&gt; from zope.catalog.catalog import Catalog
          &gt;&gt;&gt; catalog = Catalog()
          &gt;&gt;&gt; provideUtility(catalog, ICatalog, &#x27;catalog1&#x27;)
        
          &gt;&gt;&gt; from zc.catalog.catalogindex import ValueIndex
          &gt;&gt;&gt; catalog[&#x27;f1&#x27;] = ValueIndex(&#x27;f1&#x27;, IContent)
        
        Next we set up some content data to fill the indices:
        
          &gt;&gt;&gt; content = [
          ... Content(1, &#x27;a&#x27;),
          ... Content(2, &#x27;b&#x27;),
          ... Content(3, &#x27;c&#x27;),
          ... Content(4, &#x27;d&#x27;),
          ... Content(5, &#x27;c&#x27;),
          ... Content(6, &#x27;a&#x27;)]
        
        And catalog them now:
        
          &gt;&gt;&gt; for entry in content:
          ...     catalog.index_doc(intid.register(entry), entry)
        
        We query for all indexes objects::
        
          &gt;&gt;&gt; f1 = (&#x27;catalog1&#x27;, &#x27;f1&#x27;)
          &gt;&gt;&gt; displayQuery(value.All(f1))
          [1, 2, 3, 4, 5, 6]
        
        Let&#x27;s now query for all objects where ``f1`` equals &#x27;a&#x27;:
        
          &gt;&gt;&gt; f1 = (&#x27;catalog1&#x27;, &#x27;f1&#x27;)
          &gt;&gt;&gt; displayQuery(value.Eq(f1, &#x27;a&#x27;))
          [1, 6]
        
        Next, let&#x27;s find all objects where ``f1`` does not equal &#x27;a&#x27;; this is more
        efficient than the generic ``~`` operator:
        
          &gt;&gt;&gt; displayQuery(value.NotEq(f1, &#x27;a&#x27;))
          [2, 3, 4, 5]
        
        If all the items in the catalog satisfy the NotEq condition, the query
        does not crash.
        
          &gt;&gt;&gt; displayQuery(value.NotEq(f1, &#x27;z&#x27;))
          [1, 2, 3, 4, 5, 6]
        
        You can also query for all objects where the value of ``f1`` is in a set of
        values:
        
          &gt;&gt;&gt; displayQuery(value.In(f1, [&#x27;a&#x27;, &#x27;d&#x27;]))
          [1, 4, 6]
        
        The next interesting set of queries allows you to make evaluations of the
        values. For example, you can ask for all objects between a certain set of
        values:
        
          &gt;&gt;&gt; displayQuery(value.Between(f1, &#x27;a&#x27;, &#x27;c&#x27;))
          [1, 2, 3, 5, 6]
        
          &gt;&gt;&gt; displayQuery(value.Between(f1, &#x27;a&#x27;, &#x27;c&#x27;, exclude_min=True))
          [2, 3, 5]
        
          &gt;&gt;&gt; displayQuery(value.Between(f1, &#x27;a&#x27;, &#x27;c&#x27;, exclude_max=True))
          [1, 2, 6]
        
          &gt;&gt;&gt; displayQuery(value.Between(f1, &#x27;a&#x27;, &#x27;c&#x27;,
          ...                            exclude_min=True, exclude_max=True))
          [2]
        
        You can also leave out one end of the range:
        
          &gt;&gt;&gt; displayQuery(value.Between(f1, &#x27;c&#x27;, None))
          [3, 4, 5]
          &gt;&gt;&gt; displayQuery(value.Between(f1, None, &#x27;c&#x27;))
          [1, 2, 3, 5, 6]
        
        You can also use greater-equals and lesser-equals for the same purpose:
        
          &gt;&gt;&gt; displayQuery(value.Ge(f1, &#x27;c&#x27;))
          [3, 4, 5]
          &gt;&gt;&gt; displayQuery(value.Le(f1, &#x27;c&#x27;))
          [1, 2, 3, 5, 6]
        
        You can chain value queries:
        
          &gt;&gt;&gt; displayQuery(value.Ge(f1, &#x27;c&#x27;) &amp; value.Le(f1, &#x27;c&#x27;))
          [3, 5]
        
        The ``value`` module also supports ``zc.catalog`` extents. The first query is
        ``ExtentAny``, which returns all douments matching the extent. If the the
        extent is ``None``, all document ids are returned:
        
          &gt;&gt;&gt; displayQuery(value.ExtentAny(f1, None))
          [1, 2, 3, 4, 5, 6]
        
        If we now create an extent that is only in the scope of the first four
        documents,
        
          &gt;&gt;&gt; from zc.catalog.extentcatalog import FilterExtent
          &gt;&gt;&gt; extent = FilterExtent(lambda extent, uid, obj: True)
          &gt;&gt;&gt; for i in range(4):
          ...     extent.add(i, i)
        
        then only the first four are returned:
        
          &gt;&gt;&gt; displayQuery(value.ExtentAny(f1, extent))
          [1, 2, 3, 4]
        
        The opposite query is the ``ExtentNone`` query, which returns all ids in the
        extent that are *not* in the index:
        
          &gt;&gt;&gt; id = intid.register(Content(7, &#x27;b&#x27;))
          &gt;&gt;&gt; id = intid.register(Content(8, &#x27;c&#x27;))
          &gt;&gt;&gt; id = intid.register(Content(9, &#x27;a&#x27;))
        
          &gt;&gt;&gt; extent = FilterExtent(lambda extent, uid, obj: True)
          &gt;&gt;&gt; for i in range(9):
          ...     extent.add(i, i)
        
          &gt;&gt;&gt; displayQuery(value.ExtentNone(f1, extent))
          [7, 8, 9]
        
        
        Querying different indexes
        --------------------------
        
        It&#x27;s possible to specify the context when creating a query. This context
        determines which index will be searched.
        
        First setup a second registry and second catalog and populate it.
        
          &gt;&gt;&gt; catalog2 = Catalog()
          &gt;&gt;&gt; from zope.component.registry import Components
          &gt;&gt;&gt; import zope.component.interfaces
          &gt;&gt;&gt; import zope.interface
          &gt;&gt;&gt; intid1 = DummyIntId()
          &gt;&gt;&gt; @zope.interface.implementer(zope.component.interfaces.IComponentLookup)
          ... class MockSite(object):
          ...     def __init__(self):
          ...         self.registry = Components(&#x27;components&#x27;)
          ...     def queryUtility(self, interface, name=&#x27;&#x27;, default=None):
          ...         if name == &#x27;&#x27;: return intid1
          ...         else: return catalog2
          ...     def getSiteManager(self):
          ...         return self.registry
          &gt;&gt;&gt; from zope.component.hooks import setSite
          &gt;&gt;&gt; site1 = MockSite()
          &gt;&gt;&gt; setSite(site1)
          &gt;&gt;&gt; catalog2[&#x27;f1&#x27;] = FieldIndex(&#x27;f1&#x27;, IContent)
          &gt;&gt;&gt; content = [
          ... Content(1,&#x27;A&#x27;),
          ... Content(2,&#x27;B&#x27;),]
          &gt;&gt;&gt; for entry in content:
          ...     catalog2.index_doc(intid1.register(entry), entry)
        
        Now we can query this catalog by specifying the context:
        
          &gt;&gt;&gt; query = getUtility(IQuery)
          &gt;&gt;&gt; displayQuery(Eq(f1, &#x27;A&#x27;), context=site1)
          [1]
        
          &gt;&gt;&gt; displayQuery(In(f1, [&#x27;A&#x27;, &#x27;B&#x27;]), context=site1)
          [1, 2]
        
        Sorting and limiting the results
        --------------------------------
        
        It&#x27;s possible to have the resultset sorted on one of the fields in the query.
        
          &gt;&gt;&gt; catalog = Catalog()
          &gt;&gt;&gt; provideUtility(catalog, ICatalog, &#x27;catalog1&#x27;)
          &gt;&gt;&gt; catalog[&#x27;f1&#x27;] = FieldIndex(&#x27;f1&#x27;, IContent)
          &gt;&gt;&gt; catalog[&#x27;f2&#x27;] = FieldIndex(&#x27;f2&#x27;, IContent)
          &gt;&gt;&gt; catalog[&#x27;t&#x27;] = TextIndex(&#x27;t1&#x27;, IContent)
        
        First let&#x27;s set up some new data::
        
          &gt;&gt;&gt; content = [
          ... Content(1, &#x27;a&#x27;, 2, t1=&#x27;Beautiful is better than ugly.&#x27;),
          ... Content(2, &#x27;a&#x27;, 3, t1=&#x27;Explicit is better than implicit&#x27;),
          ... Content(3, &#x27;b&#x27;, 9, t1=&#x27;Simple is better than complex&#x27;),
          ... Content(4, &#x27;c&#x27;, 8, t1=&#x27;Complex is better than complicated&#x27;),
          ... Content(5, &#x27;c&#x27;, 7, t1=&#x27;Readability counts&#x27;),
          ... Content(6, &#x27;a&#x27;, 1, t1=&#x27;Although practicality beats purity&#x27;)]
        
        And catalog them now::
        
          &gt;&gt;&gt; for entry in content:
          ...     catalog.index_doc(intid.register(entry), entry)
        
        Define a convenience function for quickly displaying a result set without
        performing any sorting here ourselves.
        
          &gt;&gt;&gt; def displayResult(q, context=None, **kw):
          ...     query = getUtility(IQuery)
          ...     r = query.searchResults(q, context, **kw)
          ...     return [e for e in r]
        
        Without using sorting in the query itself, the resultset has an undefined
        order. We &quot;manually&quot; sort the results here to have something testable.
        
          &gt;&gt;&gt; f1 = (&#x27;catalog1&#x27;, &#x27;f1&#x27;)
          &gt;&gt;&gt; [r for r in sorted(displayResult(Eq(f1, &#x27;a&#x27;)))]
          [&lt;Content &quot;1&quot;&gt;, &lt;Content &quot;2&quot;&gt;, &lt;Content &quot;6&quot;&gt;]
        
        Now we sort on the f2 index.
        
          &gt;&gt;&gt; f1 = (&#x27;catalog1&#x27;, &#x27;f1&#x27;)
          &gt;&gt;&gt; displayResult(Eq(f1, &#x27;a&#x27;), sort_field=(&#x27;catalog1&#x27;, &#x27;f2&#x27;))
          [&lt;Content &quot;6&quot;&gt;, &lt;Content &quot;1&quot;&gt;, &lt;Content &quot;2&quot;&gt;]
        
        Reverse the order.
        
          &gt;&gt;&gt; f1 = (&#x27;catalog1&#x27;, &#x27;f1&#x27;)
          &gt;&gt;&gt; displayResult(Eq(f1, &#x27;a&#x27;), sort_field=(&#x27;catalog1&#x27;, &#x27;f2&#x27;), reverse=True)
          [&lt;Content &quot;2&quot;&gt;, &lt;Content &quot;1&quot;&gt;, &lt;Content &quot;6&quot;&gt;]
        
        We can limit the amount of found items.
        
          &gt;&gt;&gt; f1 = (&#x27;catalog1&#x27;, &#x27;f1&#x27;)
          &gt;&gt;&gt; displayResult(Eq(f1, &#x27;a&#x27;), sort_field=(&#x27;catalog1&#x27;, &#x27;f2&#x27;), limit=2)
          [&lt;Content &quot;6&quot;&gt;, &lt;Content &quot;1&quot;&gt;]
        
          &gt;&gt;&gt; f1 = (&#x27;catalog1&#x27;, &#x27;f1&#x27;)
          &gt;&gt;&gt; displayResult(Eq(f1, &#x27;a&#x27;), sort_field=(&#x27;catalog1&#x27;, &#x27;f2&#x27;), limit=2, start=1)
          [&lt;Content &quot;1&quot;&gt;, &lt;Content &quot;2&quot;&gt;]
        
        We can limit the reversed resultset too.
        
          &gt;&gt;&gt; f1 = (&#x27;catalog1&#x27;, &#x27;f1&#x27;)
          &gt;&gt;&gt; displayResult(
          ...   Eq(f1, &#x27;a&#x27;), sort_field=(&#x27;catalog1&#x27;, &#x27;f2&#x27;), limit=2, reverse=True)
          [&lt;Content &quot;2&quot;&gt;, &lt;Content &quot;1&quot;&gt;]
        
        You can directly pass the index as a sort field instead of a tuple:
        
          &gt;&gt;&gt; f1 = (&#x27;catalog1&#x27;, &#x27;f1&#x27;)
          &gt;&gt;&gt; displayResult(Eq(f1, &#x27;a&#x27;), sort_field=catalog[&#x27;f2&#x27;])
          [&lt;Content &quot;6&quot;&gt;, &lt;Content &quot;1&quot;&gt;, &lt;Content &quot;2&quot;&gt;]
        
        Whenever a field is used for sorting that does not support is, an error is
        raised.
        
          &gt;&gt;&gt; f1 = (&#x27;catalog1&#x27;, &#x27;f1&#x27;)
          &gt;&gt;&gt; displayResult(Eq(f1, &#x27;a&#x27;), sort_field=(&#x27;catalog1&#x27;, &#x27;t&#x27;))
          Traceback (most recent call last):
          ...
          ValueError: Index t in catalog catalog1 does not support sorting.
        
        The resultset can still be reversed and limited even if there&#x27;s no sort_field
        given (Note that the actual order of the result set when not using explicit
        sorting is not defined. In this test it is assumed that the natural order of
        the tested index is deterministic enough to be used as a proper test).
        
          &gt;&gt;&gt; f1 = (&#x27;catalog1&#x27;, &#x27;f1&#x27;)
          &gt;&gt;&gt; displayResult(Eq(f1, &#x27;a&#x27;), limit=2)
          [&lt;Content &quot;1&quot;&gt;, &lt;Content &quot;2&quot;&gt;]
        
          &gt;&gt;&gt; f1 = (&#x27;catalog1&#x27;, &#x27;f1&#x27;)
          &gt;&gt;&gt; displayResult(Eq(f1, &#x27;a&#x27;), start=1)
          [&lt;Content &quot;2&quot;&gt;, &lt;Content &quot;6&quot;&gt;]
        
          &gt;&gt;&gt; f1 = (&#x27;catalog1&#x27;, &#x27;f1&#x27;)
          &gt;&gt;&gt; displayResult(Eq(f1, &#x27;a&#x27;), start=1, limit=1)
          [&lt;Content &quot;2&quot;&gt;]
        
          &gt;&gt;&gt; f1 = (&#x27;catalog1&#x27;, &#x27;f1&#x27;)
          &gt;&gt;&gt; displayResult(Eq(f1, &#x27;a&#x27;), limit=2, reverse=True)
          [&lt;Content &quot;6&quot;&gt;, &lt;Content &quot;2&quot;&gt;]
        
        Result counters
        ---------------
        
        Result objects provide metadata about the result.
        
        Define a convenience function for obtaining a result.
        
          &gt;&gt;&gt; def getResult(q, context=None, **kw):
          ...     query = getUtility(IQuery)
          ...     return query.searchResults(q, context, **kw)
        
        Performing a query with a sort_field gives a well-defined result:
        
          &gt;&gt;&gt; f1 = (&#x27;catalog1&#x27;, &#x27;f1&#x27;)
          &gt;&gt;&gt; result = getResult(Eq(f1, &#x27;a&#x27;), sort_field=catalog[&#x27;f1&#x27;])
          &gt;&gt;&gt; [e for e in result]
          [&lt;Content &quot;1&quot;&gt;, &lt;Content &quot;2&quot;&gt;, &lt;Content &quot;6&quot;&gt;]
        
        We can access &#x27;total&#x27; and &#x27;count&#x27; properties, and &#x27;first()&#x27; on the result:
        
          &gt;&gt;&gt; result.total
          3
          &gt;&gt;&gt; result.count
          3
          &gt;&gt;&gt; result.first()
          &lt;Content &quot;1&quot;&gt;
        
        Changing &#x27;start&#x27; is reflected in the returned data:
        
        &gt;&gt;&gt; result = getResult(Eq(f1, &#x27;a&#x27;), sort_field=catalog[&#x27;f1&#x27;], start=1)
          &gt;&gt;&gt; [e for e in result]
          [&lt;Content &quot;2&quot;&gt;, &lt;Content &quot;6&quot;&gt;]
        
        It also changes &#x27;count&#x27; and &#x27;first()&#x27;:
        
          &gt;&gt;&gt; result.count
          2
          &gt;&gt;&gt; result.first()
          &lt;Content &quot;2&quot;&gt;
        
        But &#x27;total&#x27; still reflects all matches, including the hidden first one:
        
          &gt;&gt;&gt; result.total
          3
        
        Adding a limit:
        
          &gt;&gt;&gt; result = getResult(Eq(f1, &#x27;a&#x27;), sort_field=catalog[&#x27;f1&#x27;], start=1,
          ...                    limit=1)
          &gt;&gt;&gt; [e for e in result]
          [&lt;Content &quot;2&quot;&gt;]
          &gt;&gt;&gt; result.total
          3
          &gt;&gt;&gt; result.count
          1
          &gt;&gt;&gt; result.first()
          &lt;Content &quot;2&quot;&gt;
        
        The same accessors are available on an empty result:
        
          &gt;&gt;&gt; result = getResult(Eq(f1, &#x27;foo&#x27;), sort_field=catalog[&#x27;f1&#x27;])
          &gt;&gt;&gt; [e for e in result]
          []
          &gt;&gt;&gt; result.total
          0
          &gt;&gt;&gt; result.count
          0
          &gt;&gt;&gt; result.first() is None
          True
        
        Wrapper
        -------
        
        You can define a wrapper to be called on each result:
        
          &gt;&gt;&gt; from zope.location import Location
          &gt;&gt;&gt; class Wrapper(Location):
          ...    def __init__(self, parent):
          ...       self.parent = parent
          ...    def __repr__(self):
          ...       return &#x27;&lt;Wrapper &quot;{}&quot;&gt;&#x27;.format(self.parent.id)
        
          &gt;&gt;&gt; f1 = (&#x27;catalog1&#x27;, &#x27;f1&#x27;)
          &gt;&gt;&gt; displayResult(Eq(f1, &#x27;a&#x27;), wrapper=Wrapper)
          [&lt;Wrapper &quot;1&quot;&gt;, &lt;Wrapper &quot;2&quot;&gt;, &lt;Wrapper &quot;6&quot;&gt;]
        
        Locate to
        ---------
        
        You can define a location where the results should be located with a proxy:
        
          &gt;&gt;&gt; def displayParent(q, context=None, **kw):
          ...     query = getUtility(IQuery)
          ...     r = query.searchResults(q, context, **kw)
          ...     return [(e.__parent__, e) or None for e in r]
        
          &gt;&gt;&gt; f1 = (&#x27;catalog1&#x27;, &#x27;f1&#x27;)
          &gt;&gt;&gt; displayParent(Eq(f1, &#x27;a&#x27;), limit=2)
          [(None, &lt;Content &quot;1&quot;&gt;), (None, &lt;Content &quot;2&quot;&gt;)]
        
          &gt;&gt;&gt; parent = Content(&#x27;parent&#x27;)
          &gt;&gt;&gt; displayParent(Eq(f1, &#x27;a&#x27;), limit=2, locate_to=parent)
          [(&lt;Content &quot;parent&quot;&gt;, &lt;Content &quot;1&quot;&gt;), (&lt;Content &quot;parent&quot;&gt;, &lt;Content &quot;2&quot;&gt;)]
        
        This can be used with a wrapper:
        
          &gt;&gt;&gt; displayParent(Eq(f1, &#x27;a&#x27;), limit=2, wrapper=Wrapper, locate_to=parent)
          [(&lt;Content &quot;parent&quot;&gt;, &lt;Wrapper &quot;1&quot;&gt;), (&lt;Content &quot;parent&quot;&gt;, &lt;Wrapper &quot;2&quot;&gt;)]
        
        Text index
        ----------
        
        You can search on text, here all the items that contains better::
        
          &gt;&gt;&gt; from hurry.query import Text
          &gt;&gt;&gt; t1 = (&#x27;catalog1&#x27;, &#x27;t&#x27;)
          &gt;&gt;&gt; displayResult(Text(t1, &#x27;better&#x27;))
          [&lt;Content &quot;1&quot;&gt;, &lt;Content &quot;2&quot;&gt;, &lt;Content &quot;3&quot;&gt;, &lt;Content &quot;4&quot;&gt;]
        
        Invalid text query returns an empty results::
        
          &gt;&gt;&gt; displayResult(Text(t1, &#x27;?*&#x27;))
          []
        
        
        Other terms
        -----------
        
        You can do differences, here all the items that contains better but do
        have a as f1::
        
          &gt;&gt;&gt; from hurry.query import Difference
          &gt;&gt;&gt; displayResult(Difference(Text(t1, &#x27;better&#x27;), Eq(f1, &#x27;a&#x27;)))
          [&lt;Content &quot;3&quot;&gt;, &lt;Content &quot;4&quot;&gt;]
        
        
        There is a special term that allows to mix objects with catalog
        queries::
        
          &gt;&gt;&gt; from hurry.query import Objects
          &gt;&gt;&gt; displayResult(Objects(content))
          [&lt;Content &quot;1&quot;&gt;, &lt;Content &quot;2&quot;&gt;, &lt;Content &quot;3&quot;&gt;, &lt;Content &quot;4&quot;&gt;, &lt;Content &quot;5&quot;&gt;, &lt;Content &quot;6&quot;&gt;]
        
        There is a special term that allows querying objects by intid::
        
          &gt;&gt;&gt; from hurry.query import Ids
          &gt;&gt;&gt; displayResult(Ids())
          []
        
          &gt;&gt;&gt; all_intids = [intid.getId(x) for x in content]
          &gt;&gt;&gt; displayResult(Ids(*all_intids))
          [&lt;Content &quot;1&quot;&gt;, &lt;Content &quot;2&quot;&gt;, &lt;Content &quot;3&quot;&gt;, &lt;Content &quot;4&quot;&gt;, &lt;Content &quot;5&quot;&gt;, &lt;Content &quot;6&quot;&gt;]
        
          &gt;&gt;&gt; odd_intids = [intid.getId(x) for x in content if x.id % 2]
          &gt;&gt;&gt; displayResult(Ids(*odd_intids))
          [&lt;Content &quot;1&quot;&gt;, &lt;Content &quot;3&quot;&gt;, &lt;Content &quot;5&quot;&gt;]
        
        
        CHANGES
        =======
        
        3.1 (2018-08-08)
        ----------------
        
        - Add ``Ids`` term that include already known intids in a query.
        
        3.0.0 (2018-01-19)
        ------------------
        
        - Support for python 3.4, 3.5 and 3.6 in addition to python 2.7
        
        - Cleanup in preparation for python3 support:
        
          Bugfixes:
          o API change: fix And(weighted=) keyword argument typo
          o API change: remove utterly broken ``include_minimum`` and ``include_maximum``
            arguments to SetBetween(), provide ``exclude_min`` and ``exclude_max`` instead.
          o API change: fix broken SetBetween.apply(): introduce ``cache`` arg
          o Fix ExtentNone() super delegation bug
          o Fix TimingAwareCaching.report() edge condition bug
        
          Major:
          o Remove unsupported transaction_cache
        
          Minor:
          o Clarify HURRY_QUERY_TIMING environment and searchResults(timing=) type
          o Fix TimingAwareCaching.report() output typo
          o Clarify Query.searchResults(caching=) argument type
          o Remove unreachable code path from And()
        
          Dev:
          o Maximize test coverage
          o Add Travis and Tox testing configurations
          o Bypass bootstrap.py
          o Various python3 compatibility preparations
        
        
        2.6 (2018-01-10)
        ----------------
        
        - Update dependencies not to rely on ZODB3 anymore.
        
        2.5 (2017-07-17)
        ----------------
        
        - `sort_field` can be a index name or an object providing `IIndexSort` itself.
        
        - `searchResults()` accepts optional parameter `locate_to` and `wrapper`. The
          `locate_to` is used as the `__parent__` for the location proxy put arround
          the resulting objects. The `wrapper` is a callable callback that should
          accept one argument for its parameter.
        
        2.4 (2017-06-22)
        ----------------
        
        - Don&#x27;t throw a TypeError slicing unsorted results, fixes #6
        
        2.3 (2017-04-26)
        ----------------
        
        - Define a &quot;no result&quot; result object, useful for case where application code
          has an custom API for building query terms, but this application code
          decides there is no query. Callers might still expect a result-like
          object.
        
        2.2 (2017-04-26)
        ----------------
        
        - The caching option to searchResults now accepts a dict-like value and it
          will use that to allow for caching results over multiple searchResults()
          calls. The cache invalidation then is the responsibility of the caller.
        
        2.1 (2017-02-07)
        ----------------
        
        - Add the possibility to time how long a query takes. It can be
          controlled with the new ``timing`` option to ``searchResults`` or
          the ``HURRY_QUERY_TIMING`` environment variable.
        
        2.0.1 (2016-09-08)
        ------------------
        
        - Fix log line in Text term for invalid text search.
        
        2.0 (2016-09-07)
        ----------------
        
        - Add new term: Difference. It does a difference between the first and
          the following terms passed as arguments.
        
        - Add new term: Objects. It creates a result out of the objects passed
          in arguments. It let you mix real objects with existing catalog
          queries (with And, Or or Difference for instance).
        
        - Add an option start to searchResult to skip the first results in the
          results set.
        
        - Extend the result from searchResult. You have addition information
          on the result, including the total number of results without
          start/limit restriction. A method called first() return only the
          first result if available or none.
        
        - Add an option caching to searchResult to cache the result of each
          terms within a Zope transaction, speeding similar queries. If
          disabled, terms will still be cached within the same query.
        
        
        1.2 (2015-12-16)
        ----------------
        
        * Add support for an All query.
        
        1.1.1 (2012-06-22)
        ------------------
        
        * ExtentNone in set.py missed a parameter ``index_id``. Thanks to Danilo
          Botelho for the bug report.
        
        1.1.0 (2010-07-12)
        ------------------
        
        * Allow the searchResults method of a Query to take an additional keyword
          argument `sort_field` that defines that defines (catalog_name, index_name) to
          sort on. That index in that catalog should implement IIndexSort.
        
          In addition to this keyword argument, `limit` and `reverse` keyword arguments
          can be passed too, that will limit the sorted resultset and/or reverse its
          order.
        
        * Allow the searchResults method of a Query object to take an additional
          optional context argument. This context will determine which catalog
          the search is performed on.
        
        1.0.0 (2009-11-30)
        ------------------
        
        * Refresh dependencies. Use zope.catalog and zope.intid instead of
          zope.app.catalog and zope.app.intid respectively. Don&#x27;t zope.app.zapi.
        
        * Make package description more modern.
        
        * Clean up the code style.
        
        0.9.3 (2008-09-29)
        ------------------
        
        * BUG: NotEq query no longer fails when all values in the index
          satisfy the NotEq condition.
        
        0.9.2 (2006-09-22)
        ------------------
        
        * First release on the cheeseshop.
        
        0.9.1 (2006-06-16)
        ------------------
        
        * Make zc.catalog a dependency of hurry.query.
        
        0.9 (2006-05-16)
        ----------------
        
        * Separate hurry.query from the other hurry packages. Eggification work.
        
        * Support for ValueIndex from zc.catalog.
        
        0.8 (2006-05-01)
        ----------------
        
        Initial public release.
        
Keywords: zope zope3 catalog index query
Platform: UNKNOWN
Classifier: Development Status :: 5 - Production/Stable
Classifier: Natural Language :: English
Classifier: Operating System :: OS Independent
Classifier: Topic :: Internet :: WWW/HTTP
Classifier: Environment :: Web Environment
Classifier: Intended Audience :: Developers
Classifier: License :: OSI Approved :: Zope Public License
Classifier: Programming Language :: Python
Classifier: Programming Language :: Python :: 2
Classifier: Programming Language :: Python :: 2.7
Classifier: Programming Language :: Python :: 3
Classifier: Programming Language :: Python :: 3.4
Classifier: Programming Language :: Python :: 3.5
Classifier: Programming Language :: Python :: 3.6
Classifier: Programming Language :: Python :: Implementation
Classifier: Programming Language :: Python :: Implementation :: CPython
Classifier: Programming Language :: Python :: Implementation :: PyPy
Classifier: Framework :: Zope3
