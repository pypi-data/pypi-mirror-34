/*+
 *  Name:
 *     ems1Fcerr

 *  Purpose:
 *     Get the error message associated with a facility error code.

 *  Language:
 *     Starlink ANSI C

 *  Invocation:
 *     ems1Fcerr( errstr, errnum_p )

 *  Description:
 *     This routine uses the facility code files generated by the MESSGEN
 *     utility (see SUN/185) to return the error message associated with the
 *     status code errnum.
 *
 *     In the case of failure to obtain a valid facility error message,
 *     the following error idents may be displayed together with the numbers
 *     derived from the given error code.
 *     FACERR__BADARG  The given error code was not a valid facilty error code.
 *     FACERR__NOFAC   The required facilty error file was not found.
 *     FACERR__NOMSG   The required message number was not found in the file.

 *  Arguments:
 *     errstr = char * (Returned)
 *        The error message associated with the error number.
 *     errnum = INTEGER (Given)
 *        The error number as generated by the MESSGEN utility (VMS status
 *        code format).

 *  Copyright:
 *     Copyright (C) 1994 Science & Engineering Research Council.
 *     Copyright (C) 1995, 1996, 1998, 1999, 2001 Central Laboratory of the Research Councils.
 *     Copyright (C) 2006 Particle Physics & Astronomy Research Council.
 *     Copyright (C) 2008 Science and Technlogy Facilities Council.
 *     All Rights Reserved.

 *  Licence:
 *     This program is free software; you can redistribute it and/or
 *     modify it under the terms of the GNU General Public License as
 *     published by the Free Software Foundation; either version 2 of
 *     the License, or (at your option) any later version.
 *
 *     This program is distributed in the hope that it will be
 *     useful,but WITHOUT ANY WARRANTY; without even the implied
 *     warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
 *     PURPOSE. See the GNU General Public License for more details.
 *
 *     You should have received a copy of the GNU General Public License
 *     along with this program; if not, write to the Free Software
 *     Foundation, Inc., 51 Franklin Street,Fifth Floor, Boston, MA
 *     02110-1301, USA

 *  Authors:
 *     BKM: B.K. McIlwrath (STARLINK)
 *     AJC: A.J.Chipperfield (STARLINK)
 *     TIMJ: Tim Jenness (JAC, Hawaii)
 *     PWD: Peter W. Draper (JAC, Durham University)
 *     {enter_new_authors_here}

 *  History:
 *     12_AUG-1994 (BKM):
 *        Original version.
 *     20-SEP-1994 (AJC):
 *        Add special case SAI__OK to ems1_get_facility_err
 *        Reorganize error conditions and messages slightly
 *     21-JUN-1995 (AJC):
 *        Re-organise to use ems1_starf to look along EMS_PATH
 *        and, failing that, at ../help/fac_xxx_err relative to
 *        directories in PATH.
 *     02-AUG-1995 (BKM):
 *        Ensure that the file descriptor used to locate messages is closed.
 *        Rename get_facility_error to ems1_get_facility_error and make global
 *        (used by ICL).
 *     15-NOV-1996 (BKM):
 *        Correct bug - errstr being used in place of facility_name
 *     30-APR-1998 (AJC):
 *        Correct ident length and buffer length to allow 15 and 80 character
 *        strings respectively.
 *      1-JUN-1999 (AJC):
 *        Use changed name of ems1Starf
 *     21-MAR-2001 (AJC):
 *        Addition of trailing blanks not required now ems1Fcerr called from C.
 *     23-FEB-2006 (TIMJ):
 *        Use starMem
 *     16-MAY-2008 (PWD):
 *        Adapt for use from POSIX threads. Correct documentation.
 *     {enter_further_changes_here}

 *  Bugs:
 *     {note_any_bugs_here}

 *-
 */

#if HAVE_CONFIG_H
#include "config.h"
#endif

/*  Macro Statements: */
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#if USE_PTHREADS
#include <pthread.h>
#endif
#include "sae_par.h"
#include "star/mem.h"
#include "ems.h"
#include "ems_par.h"
#include "ems1.h"

/*  Function Definition: */
void ems1Fcerr( char *errstr, int *errnum_p )
{
    /*  Local Variables: */
    char *facility_name;                /* facility name */
    char *message_ident;                /* message identifier */
    char *message_text;                 /* message text */

    int length;                         /* Length of error text */
    int errlen = EMS__SZMSG;

    /* Get string pointers. */
    ems1_get_facility_error( *errnum_p, &facility_name, &message_ident,
                             &message_text );

    /*  Load message prefix. */
    if ( ( length = strlen( facility_name ) + strlen( message_ident ) + 3 )
         < errlen ) {
        (void)strcpy( errstr, facility_name);
        (void)strcat( errstr, "__");
        (void)strcat( errstr, message_ident);
    } else {
        length = 0;
    }

    /*  Load message text. */
    if ( length != 0 ) {
        if ( ( length = length + strlen( message_text ) + 3 ) < errlen ) {
            (void)strcat( errstr, ", " );
            (void)strcat( errstr, message_text );
            length = strlen( errstr );
        }
    }
    return;
}

#if USE_PTHREADS
static pthread_mutex_t foo_mutex = PTHREAD_MUTEX_INITIALIZER;
#endif


/*+ EMS1_GET_FACILITY_ERROR - interface to the facility error system
 *
 * This function translates the given 'errcode' to a facility number and a
 * message number. (As errcode is VMS compatable there is an severity code
 * available as well but this is currently unused on Unix).
 *
 * The facility code number (fac_code) is used to locate a file on the search
 * path defined by environment variable EMS_PATH (if defined).
 * If EMS_PATH is not defined, or does not produce a file, the file is looked
 * for at a pathname relative to each of the directories in the user's PATH.
 *
 * The error corresponding to the 'message number' is located and the three
 * strings facility name, message name and message text are returned. Suitable
 * defaults are used for any error condition.
 *
 * Arguments:
 *        errcode = unsigned int (given)
 *           error code in messgen format
 *        facility_name = char ** (returned)
 *           facility name
 *        error_ident = char ** (returned)
 *           message identifier
 *        error_text = char ** (retuned)
 *           message text
 *
 * Author:
 *    B.K. McIlwrath (STARLINK)
 *    P.W. Draper (JAC, Durham University)
 * History:
 *    Created: bkm, 18/08/1994
 *    Modified: bkm, 02/08/1995
 *      Close file descriptor used to search facility error files
 *    Modified: pwd, 19/05/2008
 *      Add POSIX threads support. Use mutexes to protect the cache that is
 *      shared globally. Introduce thread-specific data storage for the
 *      various result strings.
 */
void ems1_get_facility_error( unsigned int errcode, char **facility_name,
                              char **error_ident, char **error_text )
{

#define MAXFAC 10
#define BUFSIZE 82

    /* Facility location cache */
    static struct {
        int fac_code;           /* Facility code */
        char *file;             /* Facility file */
    } global_facilities[MAXFAC];

    static int global_cur_fac = 0;     /* Currently used locations in facility
                                        * cache */

    char* facility;
    char *ident;
    char *text;

    FILE *fp = NULL;
    char *tbuf;
    char *foundfile;
    char *s, *s1;
    char buffer[BUFSIZE];
    char filename[24];
    int fac_code;
    int i;
    int mess_number;
    int pathlen;

    /* Code start point, get the thread specific data character buffer. */
    tbuf = ems1Gthreadbuf();

    /* These buffers are returned, so must point at thread-specific data. */
    /* Note ems1Starf also uses this buffer so move up well past its
     * requirements (200 characters). */
    facility = *facility_name = tbuf + 300;
    ident = *error_ident = tbuf + 300 + 11;
    text = *error_text = tbuf + 300 + 11 + 17;

    /* Set default facility name */
    strcpy( facility, "FACERR" );

    /* Check the given error code */
    if ( ( errcode & 0x8000000 ) == 0 ) {

        /* Bit 27 unset - this is not a facility error */
        if ( errcode == SAI__OK ) {
            strcpy( facility, "SAI" );
            strcpy( ident, "OK" );
            sprintf( text, "application success status" );
        } else {
            strcpy( ident, "BADARG" );
            sprintf( text, "error %d (not a facility error code)",
                     errcode );
        }
        return;
    }

    /* Get the facility identifier code and the message number */
    fac_code    = (errcode >> 16) & 0x7ff;
    mess_number = (errcode >> 3)  & 0xfff;

    /* Use a mutex to lock this code section. Accesses global_facilities and
     * global_cur_fac which are global. */
#if USE_PTHREADS
    pthread_mutex_lock( &foo_mutex );
#endif

    /* Locate the facility definition file (fac_<facility_code>_err) as
     * obtained from the message source file using the messgen utility.
     * First search the local facility cache. */
    for ( i = 0; i < global_cur_fac; i++ ) {
        if ( global_facilities[i].fac_code == fac_code ) {
            fp = fopen( global_facilities[i].file, "r" );
            break;
        }
    }

    /* If not in cache, attempt to find the file along EMS_PATH */
    if ( i == global_cur_fac ) {
        fp = NULL;
        sprintf( filename, "fac_%d_err", fac_code );      /* File to find */
        if ( ems1Starf( "EMS_PATH", filename, "r", &foundfile, &pathlen ) ) {
            fp = fopen( foundfile, "r" );
        } else {
            /*  If unsuccessful, try relative to PATH */
            sprintf( filename, "../help/fac_%d_err", fac_code );
            if ( ems1Starf( "PATH", filename, "r", &foundfile, &pathlen ) ) {
                fp = fopen( foundfile, "r" );
            }
        }

        /* Cache the facility code and filename to avoid future PATH
         * searches. */
        if ( fp != NULL ) {
            char * tmpstr = NULL;
            tmpstr = starMalloc( strlen( foundfile ) + 1);
            if (tmpstr) {
               strcpy( tmpstr, foundfile );
               global_facilities[global_cur_fac].fac_code = fac_code;
               global_facilities[global_cur_fac].file = tmpstr;
               global_cur_fac++;
            }
        }
    }

    /*
     * Set defaults for message name and description
     */
    sprintf( text, "error %d (fac=%d,messid=%d)", errcode, fac_code,
             mess_number );
    if ( fp == NULL ) {

        /* Facility file not found */
        strcpy( ident, "NOFAC" );
        strcat( text, " no facility message file" );

#if USE_PTHREADS
        pthread_mutex_unlock( &foo_mutex );
#endif
        return;
    } else {
        strcpy( ident, "NOMSG" );
    }

    /*
     * Read definition file to locate specific error code
     */
    fgets( buffer, BUFSIZE, fp );
    if ( strncmp( buffer, "FACILITY", 8 ) != 0 ) {
        strcpy( ident, "BADFIL" );
        strcat( text, " bad message file format" );
        if (global_facilities[global_cur_fac].file)
          starFree( global_facilities[global_cur_fac].file );
        global_cur_fac--;
        fclose( fp );

#if USE_PTHREADS
        pthread_mutex_unlock( &foo_mutex );
#endif
        return;
    }

    /* Access to globals ends, so release mutex. */
#if USE_PTHREADS
    pthread_mutex_unlock( &foo_mutex );
#endif

    buffer[strlen(buffer)-1] = '\0';    /* remove newline */
    strcpy( facility, &buffer[9] );
    while ( fgets(buffer, BUFSIZE, fp ) != NULL) {
        if ( ( i = strtol( buffer, &s, 10 ) ) != mess_number ) {
            continue;
        }
        buffer[strlen(buffer)-1] = '\0';
        s++;
        s1 = strchr( s, ',' );
        *s1 = '\0';
        strcpy( ident, s );
        strcpy( text, ++s1 );
        fclose( fp );
        return;
    }
    fclose( fp );

    /*
     *  If we drop out here, the given message was not found.
     */
    strcat( text, " message number not found" );
    return;
}
