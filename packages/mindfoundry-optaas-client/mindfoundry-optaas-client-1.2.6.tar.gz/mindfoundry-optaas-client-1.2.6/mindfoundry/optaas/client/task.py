from typing import Any, Tuple, List, Dict, Callable

from mindfoundry.optaas.client.session import OPTaaSSession
from mindfoundry.optaas.client.utils import _pprint


class Configuration:
    """A set of values assigned to each :class:`.Parameter`, as generated by OPTaaS or defined by the user.

    Attributes:
        id (str): Unique id for the Configuration.
        values (Dict): Values assigned to each Parameter.
            Dict keys will be the Parameter names, and values will correspond to the Parameter type.
            :class:`GroupParameters <.GroupParameter>` will appear as nested Dicts.
        type (str): One of

            * `default`: all parameters are set to their default values
            * `exploration`: values are chosen so as to explore a new region of the parameter space
            * `exploitation`: values are chosen so as to improve upon a previously provided result
            * `user-defined`: values are provided by the user
    """

    def __init__(self, json: dict) -> None:
        self.id = json['id']  # pylint: disable=invalid-name
        self.values = json['values']
        self.type = json.get('type')
        self.results_url = json['_links']['results']['href']

    def __eq__(self, other):
        return self.__class__ == other.__class__ and self.__dict__ == other.__dict__

    def __repr__(self):
        return _pprint(self, 'id', 'type', 'values')


class Result:
    """The result obtained by taking a :class:`.Configuration` and running it through your scoring function.

    Must contain **either** a `score` value **or** an `error`.

    Attributes:
        id (int): Unique id for the Result.
        configuration (str): Unique id for the :class:`.Configuration` used to obtain the Result.
        score (float): Score obtained by using the :class:`.Configuration`.
        error (Any): Any data related to an error encountered when trying to use the :class:`.Configuration`.
        user_defined_data (Any): Any other data provided when storing the Result.
    """

    def __init__(self, json: dict) -> None:
        self.id = json['id']  # pylint: disable=invalid-name
        self.configuration = json['configuration']
        self.score = json.get('score')
        self.error = json.get('error')
        self.user_defined_data = json.get('userDefined')

    def __eq__(self, other):
        return self.__class__ == other.__class__ and self.__dict__ == other.__dict__

    def __repr__(self):
        return _pprint(self, 'id', 'score', 'configuration', 'user_defined_data')


class Task:
    """Allows you to access Task attributes and perform all Task-related functions.

    Attributes:
        json (Dict): The full JSON representation of this Task in OPTaaS.
        id (str): Unique id for the Task.
        title (str): Name/description as provided when the Task was created.
        parameters (List[Dict]): JSON representation of the :class:`Parameters <.Parameter>` defined for this Task.
        constraints (List[str]): List of OPTaaS string representations of the :class:`Constraints <.Constraint>` defined for this Task.
        status (str): Current status of the Task, e.g. 'running' or 'done'
        number_of_iterations (int): Number of :class:`Results <.Result>` provided for this Task so far.
        user_defined_data (Any): Any other data as provided when the Task was created.
    """

    def __init__(self, json: dict, session: OPTaaSSession) -> None:
        self.json = json
        self.id = json['id']  # pylint: disable=invalid-name
        self.parameters = json['parameters']
        self.constraints = json['constraints']
        self._update_attributes(json)

        self._session = session
        self._task_url = json['_links']['self']['href']
        self._configurations_url = json['_links']['configurations']['href']
        self._results_url = json['_links']['results']['href']
        self._complete_url = json['_links']['complete']['href']
        self._resume_url = json['_links']['resume']['href']

    def _update_attributes(self, json: dict):
        self.title = json['title']
        self.status = json['status']
        self.number_of_iterations = json['numberOfIterations']
        self.user_defined_data = json.get('userDefined')

    def run(self, scoring_function: Callable[..., float], max_iterations: int,
            score_threshold: float = None) -> Tuple[Result, Configuration]:
        """Run this task, using the provided scoring function to calculate the score for each configuration.

        Args:
            scoring_function (Callable[..., float]):
                Function that takes configuration values as arguments and returns a `float` score.
                e.g. if you have parameters x and y, your function would be `def get_score(x, y)`
            max_iterations (int):
                Max number of iterations to run, i.e. number of results to record before stopping.
            score_threshold (float, optional, defaults to target_score if defined):
                Stop running the task when the score is equal to or better than this value.

        Returns:
            A Tuple of the best recorded :class:`.Result` and the corresponding :class:`.Configuration`.

        Raises:
            :class:`.OPTaaSError` if the server is unavailable.
        """
        print(f'Running task "{self.title}" for {max_iterations} iterations')

        reached_threshold = self._reached_threshold_if_defined(score_threshold)

        print()
        configuration = self.generate_configurations(1)[0]

        for i in range(max_iterations):
            score = scoring_function(**configuration.values)

            print(f'Iteration: {i}    Score: {score}')
            print(f'Configuration: {configuration.values}')
            print()

            configuration = self.record_result(configuration, score)
            if reached_threshold(score):
                break

        self.complete()
        print('Task Completed')
        print()

        self.refresh()
        return self.get_best_result_and_configuration()

    def _reached_threshold_if_defined(self, score_threshold: float = None) -> Callable[[float], bool]:
        if score_threshold is None:
            target_score = self.json.get('targetScore')

            if target_score is None:
                print('(no score threshold set)')
                return lambda score: False

            print(f'(or until target score {target_score} is reached)')
            return self._reached_threshold(target_score)

        print(f'(or until score is {score_threshold} or better)')
        return self._reached_threshold(score_threshold)

    def _reached_threshold(self, threshold: float) -> Callable[[float], bool]:
        from mindfoundry.optaas.client.client import Goal
        if Goal[self.json['goal']] == Goal.min:
            return lambda score: score <= threshold
        return lambda score: score >= threshold

    def refresh(self):
        """Make a GET request to OPTaaS to retrieve the latest Task data and update this object accordingly."""
        response = self._session.get(self._task_url)
        self._update_attributes(response.body)

    def delete(self):
        """Delete this Task (cannot be undone)."""
        self._session.delete(self._task_url)

    def generate_configurations(self, quantity: int = 1) -> List[Configuration]:
        """Make a POST request to OPTaaS to generate a set of new :class:`Configurations <.Configuration>` for this Task.

        Args:
            quantity (int, optional, default 1): The number of configurations to generate (minimum 1).

        Returns:
            A list of the newly created :class:`Configurations <.Configuration>`.

        Raises:
            :class:`.OPTaaSError` if the server is unavailable or the quantity is invalid.
        """
        response = self._session.post(self._configurations_url + f'?quantity={quantity}', {})
        return [Configuration(json) for json in response.body['configurations']]

    def add_user_defined_configuration(self, values: Dict,
                                       score: float = None, user_defined_data: Any = None) -> Configuration:
        """Make a POST request to OPTaaS to store a new user-provided :class:`.Configuration` using the values provided.

        Also optionally store a :class:`.Result` for this Configuration using the provided `score`.

        This is useful for giving OPTaaS a "warm start" by providing some examples of good/bad Configurations.

        Args:
            values (Dict): Values assigned to each :class:`.Parameter`. See :attr:`.Configuration.values`.
            score (float, optional): Score obtained when using this Configuration.
            user_defined_data (Any, optional, ignored if `score` is not provided): Any other data to store in the Result.

        Returns:
            The newly created :class:`.Configuration`

        Raises:
            :class:`.OPTaaSError` if the values are otherwise invalid or the server is unavailable.
        """
        body: Dict = {'values': values}
        if score is not None:
            body['results'] = [self._make_result_body(score, user_defined_data)]

        response = self._session.post(self._configurations_url, body)
        return Configuration(response.body['configurations'][0])

    def record_result(self, configuration: Configuration, score: float = None, error: str = None,
                      user_defined_data: Any = None) -> Configuration:
        """Make a POST request to OPTaaS to record a :class:`.Result` for the given :class:`.Configuration`.

        Must specify **either** `score` **or** `error`.

        After the Result is recorded, OPTaaS will automatically generate the next Configuration for you to try.

        Args:
            configuration (Configuration): The Configuration used to obtain this Result.
            score (float): The score obtained.
            error (Any): Any data related to an error encountered while calculating the score.
            user_defined_data (Any, optional): Any other data you wish to store as part of this Result.

        Returns:
            The next :class:`.Configuration` generated by OPTaaS.

        Raises:
            :class:`.OPTaaSError` if the data provided is invalid or the server is unavailable.
            :class:`.ValueError` if both score and error are provided, or neither.
        """
        if (score is None) == (error is None):
            raise ValueError("Results must specify either a score or an error, not both.")

        if score is None:
            return self._post_result(configuration, {'error': error})

        body = self._make_result_body(score, user_defined_data)
        return self._post_result(configuration, body)

    def _post_result(self, configuration: Configuration, body: Dict) -> Configuration:
        response = self._session.post(configuration.results_url, body)
        return Configuration(response.body['nextConfiguration'])

    @staticmethod
    def _make_result_body(score: float, user_defined_data: Any = None) -> Dict:
        body = {'score': score}
        if user_defined_data is not None:
            body['userDefined'] = user_defined_data
        return body

    def get_configurations(self, limit: int = None) -> List[Configuration]:
        """Make a GET request to OPTaaS to retrieve a list of :class:`Configurations <.Configuration>` for this Task.

        Args:
            limit (int, optional, minimum 1): Upper bound on the number of Configurations that will be returned.

        Returns:
            The list of :class:`Configurations <.Configuration>`.

        Raises:
            :class:`.OPTaaSError` if the limit is invalid or the server is unavailable.
        """
        url = self._configurations_url
        if limit is not None:
            url += f'?limit={limit}'
        response = self._session.get(url)
        return [Configuration(json) for json in response.body['configurations']]

    def get_configuration(self, configuration_id: str) -> Configuration:
        """Make a GET request to OPTaaS to retrieve a specific :class:`.Configuration` by id.

        Args:
            configuration_id (str): Unique id for the Configuration.

        Returns:
            The retrieved :class:`.Configuration`.

        Raises:
            :class:`.OPTaaSError` if the configuration_id is invalid or the server is unavailable.
        """
        url = f'{self._configurations_url}/{configuration_id}'
        response = self._session.get(url)
        return Configuration(response.body)

    def get_results(self, limit: int = None, best_first: bool = False) -> List[Result]:
        """Make a GET request to OPTaaS to retrieve a list of :class:`Results <.Result>` for this Task.

        Args:
            limit (int, optional, minimum 1): Upper bound on the number of Results that will be returned.
            best_first (bool, optional, default False):
                If True, Results will appear in score order, with the best score first.
                If False, Results will appear in the order they were created.

        Returns:
            The list of :class:`Results <.Result>`.

        Raises:
            :class:`.OPTaaSError` if the limit is invalid or the server is unavailable.
        """
        url = self._results_url
        if limit is not None and best_first:
            url += f'?limit={limit}&order=bestFirst'
        elif best_first:
            url += '?order=bestFirst'
        elif limit is not None:
            url += f'?limit={limit}'
        response = self._session.get(url)
        return [Result(json) for json in response.body['results']]

    def get_result(self, result_id: int) -> Result:
        """Make a GET request to OPTaaS to retrieve a specific :class:`.Result` by id.

        Args:
            result_id (str): Unique id for the Result.

        Returns:
            The retrieved :class:`.Result`.

        Raises:
            :class:`.OPTaaSError` if the result_id is invalid or the server is unavailable.
        """
        url = f'{self._results_url}/{result_id}'
        response = self._session.get(url)
        return Result(response.body)

    def get_best_result_and_configuration(self) -> Tuple[Result, Configuration]:
        """Make GET requests to OPTaaS to retrieve the Result with the best score and the Configuration used to obtain it.

        Returns:
            A Tuple of the best :class:`.Result` and best :class:`.Configuration`.

        Raises:
            :class:`.OPTaaSError` if the server is unavailable.
            :class:`.ValueError` if no results have been posted for this task.
        """
        results = self.get_results(best_first=True, limit=1)
        if results:
            best_result = results[0]
            best_configuration = self.get_configuration(best_result.configuration)
            return best_result, best_configuration
        raise ValueError('No results available for this task yet')

    def complete(self):
        """Make a PUT request to OPTaaS to complete the task (no further configurations or results can be created)"""
        self._session.put(self._complete_url, {})

    def resume(self):
        """Make a PUT request to OPTaaS to resume a completed task"""
        self._session.put(self._resume_url, {})

    def __eq__(self, other):
        return self.__class__ == other.__class__ and self.__dict__ == other.__dict__

    def __repr__(self):
        return _pprint(self, 'id', 'title', 'user_defined_data', 'parameters', 'constraints')
