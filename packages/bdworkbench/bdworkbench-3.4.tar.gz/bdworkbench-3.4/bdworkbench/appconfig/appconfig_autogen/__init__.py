#
# Copyright (c) 2016 BlueData Software, Inc.
#

from __future__ import print_function
from ... import SubCommand
from ...constants import DEFAULT_BOOL_FALSE
from ...inmem_store import SIMPLESETUP_DICT, ENTRY_DICT

import os
import shutil
import argparse
import traceback

from .addfile import autogenAddfile
from .replace import autogenReplace
from .perms import autogenPermission
from .append import autogenAppend
from .execute import autogenExecute
from .sourcefile import autogenSourceFile
from .services import autogenServiceRegistration
from ...utils.config import SECTION_WB, KEY_SDKBASE, KEY_APPCONFIGDIR, KEY_STAGEDIR
from ...utils.misc import checkConfigApiVersion
from ...constants import DEFAULT_CONFIG_API_VER

def copyAppconfigStarter(config, packagePath):
    """

    """
    if not os.path.exists(packagePath):
        os.makedirs(packagePath)

    sdkbase = config.get(SECTION_WB, KEY_SDKBASE)
    commonScriptsDir = os.path.join(sdkbase, 'appbuild', 'config_scripts_common')
    for f in os.listdir(commonScriptsDir):
        src = os.path.join(commonScriptsDir, f)
        dst = os.path.join(packagePath, f)
        # Special case for appjob script.
        # We want to copy that template only if it doesn't already exist. The
        # premise is that it not autogenerated and the user may have modified
        # it to suite the specific app so, we should not overwrite it.
        if (f == "appjob") and os.path.exists(dst):
            continue

        shutil.copy2(src, dst)

class AppconfigAutogen(SubCommand):
    """

    """
    class RolesIfContext(object):
        """
        """
        def __init__(self, roles, output):
            self.roles = [] if roles == None else roles
            self.output = output

        def __enter__(self):
            if len(self.roles) > 0:
                self.output.append("if")
                for index, role in zip(range(0, len(self.roles)), self.roles):
                    if index != 0:
                        self.output.append(" ||\\\n")

                    self.output.append("  [[ \"${ROLE}\" == '%s' ]]" % role)

                self.output.append("; then\n")
                self.spaces = "    "
            else:
                self.spaces = ""

            return self

        def __exit__(self, _type, _value, _traceback):
            if len(self.roles) > 0:
                self.output.append("fi\n")

    def __init__(self, config, inmemStore, parent):
        SubCommand.__init__(self, config, inmemStore, parent, 'autogen')

    def getSubcmdDescripton(self):
        return 'Autogenerate a simple appconfig bundle.'

    def populateParserArgs(self, subparser):
        subparser.add_argument('--new', action='store_true', dest='new',
                               default=False,
                               help='Indicates the begining of a new appconfig '
                               'autogeneration sequence.')
        subparser.add_argument('--configapi', action='store', dest='configapi',
                                default=DEFAULT_CONFIG_API_VER, type=int,
                                help='The config api version used by the scripts '
                                'in the appconfig package.')
        subparser.add_argument('--generate', action='store_true', dest='generate',
                               default=DEFAULT_BOOL_FALSE,
                               help='Autogenerate the appconfig package previously '
                                    'created using --new argument.')
        subparser.add_argument('--onroles', metavar='ROLE', nargs='+', type=str,
                               action='store', default=None, dest='onroles',
                               help='When specified this restricts any of the '
                                    'operations to just the specific node role(s).'
                                    'When not spcified, the operation is executed'
                                    'on all roles by default.')

        addfile_group = subparser.add_argument_group(title='File additions',
                        description='Copy files to the deployed node.')
        addfile_group.add_argument('--pkgfile', metavar='FILE_IN_APPCONFIG_PKG',
                                   dest='pkgfile', action='append', nargs='+',
                                   default=None,
                                   help='The name(s) of the file(s) already in '
                                   'the appconfig directory are used as the '
                                   'source file(s).')
        addfile_group.add_argument('--destdir', metavar='ABSOLUTE_DIR_PATH',
                                   dest='destdir', action='append', default=None,
                                   help='Destination directory where a given '
                                   'file(s) is(are) to be copied on a deployed '
                                   'node.')
        addfile_group.add_argument('--dest', metavar='ABSOLUTE_PATH', type=str,
                                   dest='destpath', action='append', default=None,
                                   help='Absolute path where the local file '
                                        'should be placed inside the container. '
                                        'Any directories necessary to put the '
                                        'file at the location are created.')

        append_group = subparser.add_argument_group(title='File Append',
                        description='Append files with cluster specific properties')
        append_group.add_argument('--append', metavar="FILENAME", type=str,
                               dest='append', action="store", nargs=1,
                               help="Absolute path of the config file inside "
                                    "the container.")
        custom_group = subparser.add_argument_group(title='Custom scripts',
                        description='Various options to handle custome scripts')
        custom_group.add_argument('--execute', metavar="FILENAME", type=str,
                               dest='execute', action="store", nargs='+',
                               default=None,
                               help="Path of the file be executed inside the container.")
        custom_group.add_argument('--sourcefile', metavar="FILENAME", type=str,
                                    dest='sourcefile', action='store', nargs='+',
                                    default=None,
                                    help="Path of the file to be sourced.")

        perms_group = subparser.add_argument_group(title='File permissions',
                        description='Assign permissions to files or '
                                    'directories in the container image.')
        perms_group.add_argument('--abspath', metavar="ABSOLUTE_PATH", type=str,
                                 dest='abspath', action='store',
                                 help='Absolute path of the file or director whose '
                                      'permissions to set.')
        perms_group.add_argument('--perms', metavar="PERMISSION", type=str,
                                 dest='perms', action='store',
                                 help='RWX permissions to set for this file/directory.')
        perms_group.add_argument('--uid', metavar="UID", type=str, dest='uid',
                                 action='store',
                                 help='UID to set for the file or directory.')
        perms_group.add_argument('--gid', metavar="GID", type=str, dest='gid',
                                 action='store',
                                 help='GID to set for the file or directory.')

        replace_group = subparser.add_argument_group(title="Pattern replacement",
                        description="Pattern replacement instructions for "
                                    "autogenerating config file customization.")
        replace_group.add_argument('--replace', metavar="FILENAME", type=str,
                               dest='replace', action="store", nargs='+',
                               help="Absolute path of the config file inside "
                                    "the container.")
        replace_group.add_argument('--pattern', metavar="PATTERN", type=str,
                               dest='pattern', action="append",
                               help="The pattern in the configuration file to "
                                    "replace.")
        replace_group.add_argument('--macro', metavar="MACRO", type=str,
                               dest='macro', action='append', nargs='+',
                               help="A command whose output is used to replace "
                                    "the pattern. This could be a SDK defined "
                                    "function or a simple command invocation.")

        return

    def run(self, pArgs):
        if hasattr(pArgs, 'error') and pArgs.error:
            return False

        if pArgs.execute and pArgs.sourcefile:
            print("ERROR: Only one of --execute and --sourcefile is expected.")
            return False

        stagingDir = self.config.get(SECTION_WB, KEY_STAGEDIR)
        appconfigDir = self.config.get(SECTION_WB, KEY_APPCONFIGDIR)

        if pArgs.new:
            if not pArgs.configapi:
                print("ERROR: --configapi must be specified along with --new")
                return False

            checkConfigApiVersion(pArgs.configapi)

            packageName = os.path.basename(appconfigDir) + ".tgz"
            autogenDict = self.inmemStore.getDict(SIMPLESETUP_DICT)['autogen']

            # NOTE: These are updated by reference.
            autogenDict['name'] = packageName
            autogenDict['package'] = appconfigDir
            autogenDict['configapi'] =  pArgs.configapi

            return True

        try:
            autogen = self.inmemStore.getDict(SIMPLESETUP_DICT)["autogen"]
        except KeyError:
            print("ERROR: 'appconfig autogen --new --configapi <VER>' must "
                  "already be executed.")
            return False

        if pArgs.pkgfile:
            if (pArgs.destpath == None) and (pArgs.destdir == None):
                print("ERROR: --dest or --destdir must be specified with --pkgfile.")
                return False

            if (pArgs.destpath != None) and (pArgs.destdir != None):
                print("ERROR: Only one of --dest or --destdir must be specified with --pkgfile")
                return False

            isDirPath = False
            zippedArgs = None
            if pArgs.destpath != None:
                zippedArgs = zip(pArgs.pkgfile, pArgs.destpath)
            elif pArgs.destdir != None:
                zippedArgs = zip(pArgs.pkgfile, pArgs.destdir)
                isDirPath = True

            for (pkgFileList, destFileOrDir) in zippedArgs:
                for f in pkgFileList:
                    if not os.path.exists(os.path.join(appconfigDir, f)):
                        print("ERROR: File '%s' missing in '%s'." % (f, appconfigDir))
                        return False

                    if isDirPath == True:
                        autogen['addfile'][f] = {'dstfile': None,
                                                 'dstdir' : destFileOrDir,
                                                 'onroles': pArgs.onroles}
                    else:
                        autogen['addfile'][f] = {'dstfile': destFileOrDir,
                                                 'dstdir' : None,
                                                 'onroles': pArgs.onroles}

        if pArgs.append:
            if (pArgs.append == None) or (not pArgs.macro):
                print("ERROR: --append and macro must be specified")
                return False

            if (pArgs.append != None) and (not os.path.isabs(pArgs.append)):
                print("ERROR: --append must specify an absolute path.")
                return False
            macroParams = ' '.join(pArgs.macro)
            autogen['append'] = { pArgs.append : {'macro': macroParams,
                                                  'onroles': pArgs.onroles}}

        if pArgs.execute:
            executeList = autogen['execute']
            for e in pArgs.execute:
                executeList.append((pArgs.onroles, e))

        elif pArgs.sourcefile:
            sourceFiles = autogen['sourcefiles']
            for s in pArgs.sourcefile:
                sourceFiles.append((pArgs.onroles, s))

        elif pArgs.abspath:
            if not pArgs.perms:
                print("ERROR: --prems must be specified with --abspath.")
                return False

            filepath = pArgs.abspath
            autogen['perms'][filepath] = {'rwx': pArgs.perms}
            if pArgs.uid:
                autogen['perms'][filepath]['uid'] = pArgs.uid

            if pArgs.gid:
                if not pArgs.uid:
                    print("ERROR: --gid must be used along with --uid.")
                    return False
                autogen['perms'][filepath]['uid'] = pArgs.gid

            autogen['perms'][filepath]['onroles'] = pArgs.onroles
        elif pArgs.replace:
            if (not pArgs.pattern) or (not pArgs.macro):
                print("ERROR: Both --pattern and --macro are required args with --repalce.")
                return False

            replaceList = autogen['replace']
            for path in pArgs.replace:
                for (pattern, macro) in zip(pArgs.pattern, pArgs.macro):
                    # ideally the macro must be enclosed in double quotes. Then
                    # macro[0] will be the whole macro we want to execute. But,
                    # in case it is in double quotes we end up with a list of
                    # words. All these words still belong to the same macro.
                    if len(macro) == 1:
                        useMacro = macro[0]
                    else:
                        useMacro = ' '.join(macro)

                    replaceList.append({'path' : path,
                                        'onroles'    : pArgs.onroles,
                                        'substitute' : {'pattern': pattern,
                                                        'macro' : useMacro}})
        elif pArgs.generate:
            return self._build_appconfig_package(autogen, self.inmemStore.getDict(ENTRY_DICT))

        return True

    def complete(self, text, argsList):
        return []

    def getRoleIfContext(self, rolesList, outputLines):
        return AppconfigAutogen.RolesIfContext(rolesList, outputLines)

    def _build_appconfig_package(self, autogenDict, entryDict):
        """

        """
        packagePath = autogenDict["package"]

        try:
            # Don't remove the entire directory as the developer may have
            # some additional files in the directory. Instead, only overwrite
            # the files copied by the SDK.
            copyAppconfigStarter(self.config, packagePath)

            # Append the newly generated code block to the startscript.
            with open(os.path.join(packagePath, 'startscript'), 'a') as f:
                lines = []
                autogenSourceFile(self, lines, autogenDict)
                autogenAddfile(self, lines, packagePath, autogenDict, entryDict)
                autogenReplace(self, lines, autogenDict, entryDict)
                autogenAppend(self, lines, autogenDict, entryDict)
                autogenPermission(self, lines, autogenDict, entryDict)
                autogenExecute(self, lines, autogenDict, entryDict)

                # FYI: The system scripts for the services were specified in the
                # 'service add' command.
                autogenServiceRegistration(self, lines, autogenDict, entryDict)

                f.writelines(lines)
                f.flush()

            print("Successfully auto generated the application configuration sripts.")
            return True
        except Exception as e:
            print("EXCEPTION while generating appconfig: ", e)
            traceback.print_exc()
            return False

__all__ = [ "AppconfigAutogen", "copyAppconfigStarter" ]
SubCommand.register(AppconfigAutogen)
