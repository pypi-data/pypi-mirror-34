<!DOCTYPE html>
<meta charset="utf-8">
<style>
    body {
        font: 10px sans-serif;
        shape-rendering: crispEdges;
    }

    .day {
        fill: #fff;
        stroke: #ccc;
    }

    .month {
        fill: none;
        stroke: #000;
        stroke-width: 2px;
    }
</style>

<body>
    <script src="//d3js.org/d3.v3.min.js"></script>
    <script>
        var width = {width},
            height = {height},
            cellSize = height / 10; // cell size

        var format = d3.time.format("%Y-%m-%d");

        var csv = {data}

        var color = d3.scale.linear()
            .domain([0, d3.max(csv, function(v, i) {
                return v.Value
            })])
            .range(["red", "blue"]);

        //Get the max and the min of the dates
        var minDate = format.parse(csv[0].Date),
            maxDate = format.parse(csv[csv.length - 1].Date);
        debugger;

        var svg = d3.select("body").selectAll("svg")
            .data(d3.range(minDate.getFullYear(), maxDate.getFullYear()+1))
            .enter().append("svg")
            .attr("width", width)
            .attr("height", height)
            .append("g")
            .attr("transform", "translate(" + ((width - cellSize * 53) / 2) + "," + (height - cellSize * 7 - 1) + ")");

        svg.append("text")
            .attr("transform", "translate(-6," + cellSize * 3.5 + ")rotate(-90)")
            .style("text-anchor", "middle")
            .text(function(d) {
                return d;
            });

        var rect = svg.selectAll(".day")
            .data(function(d) {
                return d3.time.days(new Date(d, 0, 1), new Date(d + 1, 0, 1));
            })
            .enter().append("rect")
            .attr("class", "day")
            .attr("width", cellSize)
            .attr("height", cellSize)
            .attr("x", function(d) {
                return d3.time.weekOfYear(d) * cellSize;
            })
            .attr("y", function(d) {
                return d.getDay() * cellSize;
            })
            .datum(format);

        rect.append("title")
            .text(function(d) {
                return d;
            });

        svg.selectAll(".month")
            .data(function(d) {
                return d3.time.months(new Date(d, 0, 1), new Date(d + 1, 0, 1));
            })
            .enter().append("path")
            .attr("class", "month")
            .attr("d", monthPath);

        var data = d3.nest()
            .key(function(d) {
                return d.Date;
            })
            .rollup(function(d) {
                return parseInt(d[0].Value);
            })
            .map(csv);

        rect.filter(function(d) {
                return d in data;
            })
            .style("fill", function(d) {
                return color(data[d]);
            })
            .select("title")
            .text(function(d) {
                return d + ": " + data[d];
            });


        function monthPath(t0) {
            var t1 = new Date(t0.getFullYear(), t0.getMonth() + 1, 0),
                d0 = t0.getDay(),
                w0 = d3.time.weekOfYear(t0),
                d1 = t1.getDay(),
                w1 = d3.time.weekOfYear(t1);
            return "M" + (w0 + 1) * cellSize + "," + d0 * cellSize + "H" + w0 * cellSize + "V" + 7 * cellSize + "H" + w1 * cellSize + "V" + (d1 + 1) * cellSize + "H" + (w1 + 1) * cellSize + "V" + 0 + "H" + (w0 + 1) * cellSize + "Z";
        }
    </script>
