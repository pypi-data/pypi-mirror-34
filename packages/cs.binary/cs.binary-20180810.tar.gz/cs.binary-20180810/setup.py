#!/usr/bin/env python
from setuptools import setup
setup(
  name = 'cs.binary',
  description = 'Facilities associated with binary data.',
  author = 'Cameron Simpson',
  author_email = 'cs@cskk.id.au',
  version = '20180810',
  url = 'https://bitbucket.org/cameron_simpson/css/commits/all',
  classifiers = ['Development Status :: 4 - Beta', 'Environment :: Console', 'Programming Language :: Python', 'Programming Language :: Python :: 3', 'Intended Audience :: Developers', 'Operating System :: OS Independent', 'Topic :: Software Development :: Libraries :: Python Modules', 'License :: OSI Approved :: GNU General Public License v3 (GPLv3)'],
  install_requires = ['cs.buffer'],
  keywords = ['python3'],
  long_description = "Facilities associated with binary data.\n\nThis module requires Python 3 and recommends Python 3.6+ because\n    it uses abc.ABC, because a Python 2 bytes object is too weak\n    (just a str) as also is my cs.py.bytes hack class and because\n    the keyword based Packet initiialisation benefits from keyword\n    argument ordering.\n\n    * Cameron Simpson <cs@cskk.id.au> 22jul2018\n\n## Class `BytesesField`\n\nMRO: `PacketField`, `abc.ABC`  \nA field containing a list of bytes chunks.\n\nThe following attributes are defined:\n* `value`: the gathered data as a list of bytes instances,\n  or None if the field was gathered with `discard_data` true.\n* `offset`: the starting offset of the data.\n* `end_offset`: the ending offset of the data.\n\nThe `offset` and `end_offset` values are recorded during the\nparse, and may become irrelevant if the field's contents are\nchanged.\n\n## Class `BytesField`\n\nMRO: `PacketField`, `abc.ABC`  \nA field of bytes.\n  \n\n## Class `BytesRunField`\n\nMRO: `PacketField`, `abc.ABC`  \nA field containing a continuous run of a single bytes value.\n\nThe following attributes are defined:\n* `length`: the length of the run\n* `bytes_value`: the repeated bytes value\n\nThe property `value` is computed on the fly on every reference\nand returns a value obeying the buffer protocol: a bytes or\nmemoryview object.\n\n## Class `EmptyPacketField`\n\nMRO: `PacketField`, `abc.ABC`  \nAn empty data field, used as a placeholder for optional\nfields when they are not present.\n\nThe singleton EmptyField is a predefined instance.\n\n## Function `fixed_bytes_field(length, class_name=None)`\n\nFactory for BytesField subclasses built from fixed length byte strings.\n  \n\n## Function `flatten(chunks)`\n\nFlatten `chunks` into an iterable of bytes instances.\n\nThis exists to allow subclass methods to easily return ASCII\nstrings or bytes or iterables or even None, in turn allowing\nthem to simply return their superclass' chunks iterators\ndirectly instead of having to unpack them.\n\n## Class `Int16BE`\n\nMRO: `PacketField`, `abc.ABC`  \nA PacketField which parses and transcribes the struct format `'>h'`.\n\n## Class `Int16LE`\n\nMRO: `PacketField`, `abc.ABC`  \nA PacketField which parses and transcribes the struct format `'<h'`.\n\n## Class `Int32BE`\n\nMRO: `PacketField`, `abc.ABC`  \nA PacketField which parses and transcribes the struct format `'>l'`.\n\n## Class `Int32LE`\n\nMRO: `PacketField`, `abc.ABC`  \nA PacketField which parses and transcribes the struct format `'<l'`.\n\n## Class `ListField`\n\nMRO: `PacketField`, `abc.ABC`  \nA field which is a list of other fields.\n  \n\n## Function `multi_struct_field(struct_format, subvalue_names=None, class_name=None)`\n\nFactory for PacketField subclasses build around complex struct formats.\n\nParameters:\n* `struct_format`: the struct format string\n* `subvalue_names`: an optional namedtuple field name list;\n  if supplied then the field value will be a namedtuple with\n  these names\n* `class_name`: option name for the generated class\n\n## Class `Packet`\n\nMRO: `PacketField`, `abc.ABC`  \nBase class for compound objects derived from binary data.\n  \n\n## Class `PacketField`\n\nMRO: `abc.ABC`  \nA record for an individual packet field.\n  \n\n## Function `struct_field(struct_format, class_name)`\n\nFactory for PacketField subclasses built around a single struct format.\n\nParameters:\n* `struct_format`: the struct format string, specifying a\n  single struct field\n* `class_name`: the class name for the generated class\n\nExample:\n\n    >>> UInt16BE = struct_field('>H', class_name='UInt16BE')\n    >>> UInt16BE.__name__\n    'UInt16BE'\n    >>> UInt16BE.format\n    '>H'\n    >>> UInt16BE.struct   #doctest: +ELLIPSIS\n    <Struct object at ...>\n    >>> field, offset = UInt16BE.from_bytes(bytes((2,3,4)))\n    >>> field\n    UInt16BE(515)\n    >>> offset\n    2\n    >>> field.value\n    515\n\n## Function `structtuple(class_name, struct_format, subvalue_names)`\n\nConvenience wrapper for multi_struct_field.\n  \n\n## Class `UInt16BE`\n\nMRO: `PacketField`, `abc.ABC`  \nA PacketField which parses and transcribes the struct format `'>H'`.\n\n## Class `UInt16LE`\n\nMRO: `PacketField`, `abc.ABC`  \nA PacketField which parses and transcribes the struct format `'<H'`.\n\n## Class `UInt32BE`\n\nMRO: `PacketField`, `abc.ABC`  \nA PacketField which parses and transcribes the struct format `'>L'`.\n\n## Class `UInt32LE`\n\nMRO: `PacketField`, `abc.ABC`  \nA PacketField which parses and transcribes the struct format `'<L'`.\n\n## Class `UInt64BE`\n\nMRO: `PacketField`, `abc.ABC`  \nA PacketField which parses and transcribes the struct format `'>Q'`.\n\n## Class `UInt64LE`\n\nMRO: `PacketField`, `abc.ABC`  \nA PacketField which parses and transcribes the struct format `'<Q'`.\n\n## Class `UInt8`\n\nMRO: `PacketField`, `abc.ABC`  \nA PacketField which parses and transcribes the struct format `'B'`.\n\n## Class `UTF8NULField`\n\nMRO: `PacketField`, `abc.ABC`  \nA NUL terminated UTF-8 string.\n  ",
  long_description_content_type = 'text/markdown',
  package_dir = {'': 'lib/python'},
  py_modules = ['cs.binary'],
)
