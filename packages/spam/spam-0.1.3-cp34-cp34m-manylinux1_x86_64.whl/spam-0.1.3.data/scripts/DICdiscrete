#!/opt/python/cp34-cp34m/bin/python

from __future__ import print_function
import sys
import os
import numpy
import tifffile
import argparse
import scipy.ndimage

###############################################################
# WARNING: Since we do not allow ourselves to interpolate
# the mask on im1, some complications in the code are
# unfortunately necessary:
# -
###############################################################
import spam.DIC.correlate as corr
import spam.DIC.transformationOperator as transf
import spam.label.toolkit as ltk
import spam.helpers.tsvio
import spam.helpers.optionsParser


# The following two lines avoid "UserWarning: From scipy 0.13.0, the output shape of zoom()"
import warnings
warnings.filterwarnings('ignore', '.*output shape of zoom.*')

# Make sure prints come out straight away
sys.stdout = os.fdopen(sys.stdout.fileno(), 'w', 0)

# Define argument parser object
parser = argparse.ArgumentParser()

# Parse arguments with external helper function
args = spam.helpers.optionsParser.DICdiscreteParser(parser)

print("Current Settings:")
argsDict = vars(args)
for key in sorted(argsDict):
    print("\t{}: {}".format(key, argsDict[key]))

print("\nLoading Data...", end='')
im1 = tifffile.imread(args.im1).astype('<f4')
lab1 = tifffile.imread(args.lab1).astype('<u2')
im2 = tifffile.imread(args.im2).astype('<f4')
print("done."),

nodeMatrixFprev = None

###############################################################
# Analyse labelled volume in state 01 in order to get bounding
# boxes and centres of mass for correlation
###############################################################
numberOfLabels = (lab1.max() + 1).astype('u4')

print("Number of labels = {}\n".format(numberOfLabels))

print("Calculating Bounding Boxes and Centres of Mass of all labels.")
boundingBoxes = ltk.getBoundingBoxes(lab1)
centresOfMass = ltk.getCentresOfMass(lab1, boundingBoxes=boundingBoxes)
print("\n  ")

###############################################################
# Set up kinematics array
###############################################################
outputMatrix = numpy.zeros((numberOfLabels, 19))

Ffield = numpy.zeros((numberOfLabels, 4, 4))
pixelsearchCC = numpy.zeros((numberOfLabels))
subpixelError = numpy.zeros((numberOfLabels))
subpixelIterations = numpy.zeros((numberOfLabels))
subpixelReturnStatus = numpy.zeros((numberOfLabels))
subpixelDeltaFnorm = numpy.zeros((numberOfLabels))

# Initialise field of Fs with the identity matrix
for node in range(numberOfLabels):
    Ffield[node] = numpy.eye(4)


searchRange = {'xRange': [args.PSR[4], args.PSR[5]],
               'yRange': [args.PSR[2], args.PSR[3]],
               'zRange': [args.PSR[0], args.PSR[1]]}


##################################################################
# Rough estimates of displacement:
# Option 1: Do a registration (single-image correlation)
# Option 2: Load a previous registration
# Option 3: Perform a displacement-only pixel search
# Option X: (one day) Perform FFT correlation
##################################################################

# Option 1 -- attempt registration
#####################################
registrationSuccessful = False
if args.REG:
    print("\tDICdiscrete: Starting registration")
    if args.REG_BIN == 1:
        im1Reg = im1
        im2Reg = im2
    else:
        im1Reg = scipy.ndimage.zoom(im1, 1.0/float(args.REG_BIN))
        im2Reg = scipy.ndimage.zoom(im2, 1.0/float(args.REG_BIN))

    regReturns = spam.DIC.correlate.lucasKanade(im1Reg, im2Reg,
                                                margin=int(args.REG_MARGIN*min(im1Reg.shape)),
                                                interpolationOrder=1,
                                                maxIterations=500,
                                                minFchange=0.0001,
                                                verbose=True,
                                                imShowProgress=None)

    if regReturns['returnStatus'] != 2:
        print("\tDICdiscrete: Registration did not converge, try increasing the registration margin?")
    else:
        print("\tDICdiscrete: Registration converged beautifully...")
        registrationSuccessful = True

        print("\tTranslations (px)")
        print("\t\t", regReturns['transformation']['t'])
        print("\tRotations (deg)")
        print("\t\t", regReturns['transformation']['r'])

        regF = regReturns['Fcentre']
        regCentre = numpy.array(im1Reg.shape)/2.0

        # Not right in 100% of cases, but disactivate pixelSearch if the registration has converged
        args.PS = False
        # Also disactive loading further guesses.
        args.FFILE = None

        # if args.TSV:
        spam.helpers.tsvio.writeRegistration(args.OUT_DIR+"/"+args.PREFIX+"-bin{:d}".format(args.REG_BIN)+"-registration.tsv", regCentre, regReturns)

        # HACK: overwrite variables regF, regCentre with binning 1 versions
        if args.REG_BIN != 1:
            regF[0:3, 3] *= float(args.REG_BIN)
            regCentre *= float(args.REG_BIN)

    # tidy up after registration:
    del im1Reg, im2Reg

# Option 2 - load previous DVC
#################################
if args.FFILE is not None:
    FfromFile = spam.helpers.tsvio.readTSV(args.FFILE.name, fieldBinRatio=args.FFILE_BIN_RATIO)

    # We read an F file, also prevent pixel search
    args.PS = False

    # If the read F-file has only one line -- it's a single point registration!
    if FfromFile['fieldCoords'].shape[0] == 1:
        regF = FfromFile['Ffield'][0]
        regCentre = FfromFile['fieldCoords'][0]
        registrationSuccessful = True
        print("\tI read a registration from a file.")
        print("\tTranslations (px)")
        print("\t\t", spam.DIC.transformationOperator.FtoTransformation(regF)['t'])
        print("\tRotations (deg)")
        print("\t\t", spam.DIC.transformationOperator.FtoTransformation(regF)['r'])

    # If the read F-file contains multiple lines it's an F field!
    else:
        # Disactivate the application of registration
        registrationSuccessful = False

        # Replace F componets of the current grid to zeros
        for node in range(centresOfMass.shape[0]):
            Ffield[node][:-1] = numpy.zeros((3, 4))

        # Read the coordinates and values of the input F field
        fieldCoords = FfromFile["fieldCoords"]

        # Check if the correction of the input field is asked
        if args.CF:
            fieldValues = spam.DIC.transformationOperator.correctFfield(fileName=args.FFILE.name,
                                                                        fieldBinRatio=args.FFILE_BIN_RATIO,
                                                                        correctBadPoints=True, neighbours=args.NEIGHBOURS)
        else:
            fieldValues = FfromFile["Ffield"]

        # Create the k-d tree of the coordinates of the input F field
        from scipy.spatial import KDTree
        neighbours = args.NEIGHBOURS
        fieldTree = KDTree(fieldCoords)

        # Loop over each point of the current grid
        for node in xrange(centresOfMass.shape[0]):
            # if verbose: print "\nWorking on node {} {:0.2f}%".format( node, (node/float(numberofPoints))*100)

            # Calculate the distance of the point of the current grid to the points of the input F field
            distance, indices = fieldTree.query(centresOfMass[node], k=neighbours)

            # Check if we've hit the same point in the two grids
            if numpy.any(distance == 0):

                # Copy F of that point to the F in the current grid point
                Ffield[node] = fieldValues[indices][numpy.where(distance == 0)].copy()

            # If not, consider the closest neighbours
            else:

                # Compute the "Inverse Distance Weighting" since the closest points should have the major influence
                weightSumInv = sum(1/distance)

                # Loop over each neighbour
                for neighbour in xrange(neighbours):
                    # Calculate its weight
                    weightInv = (1/distance[neighbour])/float(weightSumInv)

                    # Fill the F of the current grid point with the weighted F components of the ith nearest neighbour in the input F field
                    Ffield[node][:-1] += fieldValues[indices[neighbour]][:-1]*weightInv


# Apply registration (just done or loaded) to mesh
if registrationSuccessful:
    # We have a registration to apply to all points.
    # This is done in 2 steps:
    #   1. by copying the registration's little F to the Fs of all points
    #   2. by calling the FtoTranformation function to compute the translation of each point
    for node in range(centresOfMass.shape[0]):
        Ffield[node] = regF.copy()
        Ffield[node][0:3, -1] = transf.FtoTransformation(regF.copy(), Fcentre=regCentre, Fpoint=centresOfMass[node])["t"]


print("\tStarting Node correlation")
# for label in [17533]:
for label in xrange(1, numberOfLabels):
    print("\r\t\tCorrelating label {:04d} of {:04d}\t".format(label+1, numberOfLabels), end='')

    returns = ltk.getLabel(lab1, label,
                           extractCube=False,
                           boundingBoxes=boundingBoxes,
                           centresOfMass=centresOfMass,
                           margin=max(args.LABEL_DILATE, 0)+1,
                           maskOtherLabels=args.MASK,
                           labelDilate=args.LABEL_DILATE)
    # Maskette 1 is either a boolean array if args.MASK
    #   otherwise it contains ints i.e., labels
    if args.MASK:
        maskette1 = returns['subvol']
    else:
        maskette1 = None
    slicette1 = returns['slice']
    imagette1 = im1[slicette1].copy()

    if numpy.sum(maskette1) > args.VOLUME_THRESHOLD:
        if args.PS:
            # print "DICdiscrete.py: Pixel Search hiatus"
            returns = corr.pixelSearch(imagette1, im2,
                                       searchRange=searchRange,
                                       searchCentre=centresOfMass[label])
            Ffield[label, 0:3, 3] = returns['transformation']['t']
            pixelsearchCC[label] = returns['cc']

        if args.SUBPIXEL:
            # Apply this point's F (at the point's origin, i.e., the top HWS away from point)
            nodeDisplacement = numpy.round(Ffield[label][0:3, -1])

            # Assume no displacement
            slicette2 = [slice(int(boundingBoxes[label][0]-args.SUBPIXEL_MARGIN-max(args.LABEL_DILATE, 0)+nodeDisplacement[0]), int(boundingBoxes[label][1]+args.SUBPIXEL_MARGIN+max(args.LABEL_DILATE, 0)+nodeDisplacement[0]+1)),
                         slice(int(boundingBoxes[label][2]-args.SUBPIXEL_MARGIN-max(args.LABEL_DILATE, 0)+nodeDisplacement[1]), int(boundingBoxes[label][3]+args.SUBPIXEL_MARGIN+max(args.LABEL_DILATE, 0)+nodeDisplacement[1]+1)),
                         slice(int(boundingBoxes[label][4]-args.SUBPIXEL_MARGIN-max(args.LABEL_DILATE, 0)+nodeDisplacement[2]), int(boundingBoxes[label][5]+args.SUBPIXEL_MARGIN+max(args.LABEL_DILATE, 0)+nodeDisplacement[2]+1))]

            Ftemp = Ffield[label].copy()
            Ftemp[0:3, -1] -= nodeDisplacement

            try:
                returns = corr.lucasKanade(im2[slicette2].copy(),  # im1 for lucasKanade -- this should be bigger
                                           imagette1,             # im2 for lucasKanade
                                           im2mask=maskette1,
                                           margin=1,             # WARNING: checkme
                                           Finit=numpy.linalg.inv(Ftemp),
                                           maxIterations=args.SUBPIXEL_MAX_ITERATIONS,
                                           minFchange=args.SUBPIXEL_MIN_F_CHANGE,
                                           interpolationOrder=args.SUBPIXEL_INTERPOLATION_ORDER,
                                           verbose=False,
                                           imShowProgress=None)

                # Keep pixel search translations
                # transTemp = Ffield[ label, 0:3, 3 ].copy()
                # Overwrite transformation operator
                Ffield[label] = numpy.linalg.inv(returns['Fcentre'])
                # Add back in the translation from the pixel-search
                Ffield[label, 0:3, 3] += nodeDisplacement

                subpixelError[label] = returns['error']
                subpixelIterations[label] = returns['iterationNumber']
                subpixelReturnStatus[label] = returns['returnStatus']
                subpixelDeltaFnorm[label] = returns['deltaFnorm']
                print("error={:05.0f}\titerations={:02d}\treturnStat={:+1d}".format(returns['error'], returns['iterationNumber'], returns['returnStatus']), end='')

            except ValueError:
                print("Value Error", end='')
print()

outMatrix = numpy.array([numpy.array(range(numberOfLabels)),
                         centresOfMass[:, 0], centresOfMass[:, 1], centresOfMass[:, 2],
                         Ffield[:, 0, 3],      Ffield[:, 1, 3],      Ffield[:, 2, 3],
                         Ffield[:, 0, 0],      Ffield[:, 0, 1],      Ffield[:, 0, 2],
                         Ffield[:, 1, 0],      Ffield[:, 1, 1],      Ffield[:, 1, 2],
                         Ffield[:, 2, 0],      Ffield[:, 2, 1],      Ffield[:, 2, 2],
                         pixelsearchCC,
                         subpixelError, subpixelIterations, subpixelReturnStatus, subpixelDeltaFnorm]).T

numpy.savetxt(args.OUT_DIR+"/"+args.PREFIX+"-discreteDVC.tsv",
              outMatrix,
              fmt='%.7f',
              delimiter='\t',
              newline='\n',
              comments='',
              header="Label\tZpos\tYpos\tXpos\t" +
              "Zdisp\tYdisp\tXdisp\t" +
              "F11\tF12\tF13\t" +
              "F21\tF22\tF23\t" +
              "F31\tF32\tF33\t" +
              "PS-CC\tSubPixError\tSubPixIterations\tSubPixReturnStat\tSubPixDeltaFnorm")
# zDisp = ltk.convertLabelToFloat( lab1, outputMatrix[ :, 1 ] )
# tifffile.imsave( os.environ.get('RWROOT')+"zDisp-lab.tif", zDisp )
